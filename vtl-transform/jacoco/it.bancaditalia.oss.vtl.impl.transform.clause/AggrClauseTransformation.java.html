<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AggrClauseTransformation.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">vtl-transform</a> &gt; <a href="index.source.html" class="el_package">it.bancaditalia.oss.vtl.impl.transform.clause</a> &gt; <span class="el_source">AggrClauseTransformation.java</span></div><h1>AggrClauseTransformation.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright 2020, Bank Of Italy
 *
 * Licensed under the EUPL, Version 1.2 (the &quot;License&quot;);
 * You may not use this work except in compliance with the
 * License.
 * You may obtain a copy of the License at:
 *
 * https://joinup.ec.europa.eu/sites/default/files/custom-page/attachment/2020-03/EUPL-1.2%20EN.txt
 *
 * Unless required by applicable law or agreed to in
 * writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; basis,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied.
 *
 * See the License for the specific language governing
 * permissions and limitations under the License.
 *******************************************************************************/
package it.bancaditalia.oss.vtl.impl.transform.clause;

import static it.bancaditalia.oss.vtl.util.Utils.entriesToMap;
import static java.util.Collections.emptySet;
import static java.util.stream.Collectors.joining;
import static java.util.stream.Collectors.toList;
import static java.util.stream.Collectors.toSet;

import java.util.AbstractMap.SimpleEntry;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.function.BiFunction;
import java.util.stream.Stream;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import it.bancaditalia.oss.vtl.exceptions.VTLMissingComponentsException;
import it.bancaditalia.oss.vtl.impl.transform.dataset.LightF2DataSet;
import it.bancaditalia.oss.vtl.impl.transform.exceptions.VTLIncompatibleRolesException;
import it.bancaditalia.oss.vtl.impl.transform.exceptions.VTLInvalidParameterException;
import it.bancaditalia.oss.vtl.impl.transform.ops.AggregateTransformation;
import it.bancaditalia.oss.vtl.impl.transform.ops.TransformationImpl;
import it.bancaditalia.oss.vtl.impl.transform.scope.DatapointScope;
import it.bancaditalia.oss.vtl.impl.transform.scope.ThisScope;
import it.bancaditalia.oss.vtl.impl.types.dataset.DataPointImpl.DataPointBuilder;
import it.bancaditalia.oss.vtl.impl.types.dataset.DataStructureComponentImpl;
import it.bancaditalia.oss.vtl.impl.types.dataset.DataStructureImpl.Builder;
import it.bancaditalia.oss.vtl.impl.types.dataset.LightDataSet;
import it.bancaditalia.oss.vtl.impl.types.domain.Domains;
import it.bancaditalia.oss.vtl.impl.types.exceptions.VTLIncompatibleTypesException;
import it.bancaditalia.oss.vtl.impl.types.exceptions.VTLInvariantIdentifiersException;
import it.bancaditalia.oss.vtl.model.data.ComponentRole;
import it.bancaditalia.oss.vtl.model.data.ComponentRole.Identifier;
import it.bancaditalia.oss.vtl.model.data.ComponentRole.Measure;
import it.bancaditalia.oss.vtl.model.data.ComponentRole.NonIdentifier;
import it.bancaditalia.oss.vtl.model.data.DataPoint;
import it.bancaditalia.oss.vtl.model.data.DataSet;
import it.bancaditalia.oss.vtl.model.data.DataSet.VTLDataSetMetadata;
import it.bancaditalia.oss.vtl.model.data.DataStructure;
import it.bancaditalia.oss.vtl.model.data.DataStructureComponent;
import it.bancaditalia.oss.vtl.model.data.ScalarValue;
import it.bancaditalia.oss.vtl.model.data.ScalarValue.VTLScalarValueMetadata;
import it.bancaditalia.oss.vtl.model.data.VTLValue;
import it.bancaditalia.oss.vtl.model.data.VTLValue.VTLValueMetadata;
import it.bancaditalia.oss.vtl.model.transform.LeafTransformation;
import it.bancaditalia.oss.vtl.model.transform.Transformation;
import it.bancaditalia.oss.vtl.model.transform.TransformationScheme;
import it.bancaditalia.oss.vtl.util.Utils;

public class AggrClauseTransformation extends DatasetClauseTransformation
{
	private static final long serialVersionUID = 1L;

<span class="nc" id="L76">	private final static Logger LOGGER = LoggerFactory.getLogger(AggrClauseTransformation.class);</span>

	public static class AggrClauseItem extends TransformationImpl
	{
		private static final long serialVersionUID = 1L;
		
		private final String                         component;
		private final AggregateTransformation        operand;
		private final Class&lt;? extends ComponentRole&gt; role;

		public AggrClauseItem(Class&lt;? extends ComponentRole&gt; role, String component, AggregateTransformation operand)
<span class="nc" id="L87">		{</span>
<span class="nc" id="L88">			this.component = component;</span>
<span class="nc" id="L89">			this.operand = operand;</span>
<span class="nc" id="L90">			this.role = role;</span>
<span class="nc" id="L91">		}</span>

		public String getComponent()
		{
<span class="nc" id="L95">			return component;</span>
		}

		public AggregateTransformation getOperand()
		{
<span class="nc" id="L100">			return operand;</span>
		}

		public Class&lt;? extends ComponentRole&gt; getRole()
		{
<span class="nc" id="L105">			return role;</span>
		}

		@Override
		public String toString()
		{
<span class="nc bnc" id="L111" title="All 2 branches missed.">			return (role != null ? role.getSimpleName().toUpperCase() + &quot; &quot; : &quot;&quot;) + component + &quot; := &quot; + operand;</span>
		}

		@Override
		public boolean isTerminal()
		{
<span class="nc" id="L117">			return false;</span>
		}

		@Override
		public Set&lt;LeafTransformation&gt; getTerminals()
		{
<span class="nc" id="L123">			return operand.getTerminals();</span>
		}

		@Override
		public VTLValue eval(TransformationScheme session)
		{
<span class="nc" id="L129">			return operand.eval(session);</span>
		}

		@Override
		public VTLValueMetadata getMetadata(TransformationScheme scheme)
		{
<span class="nc" id="L135">			return operand.getMetadata(scheme);</span>
		}
	}

	private final List&lt;AggrClauseItem&gt; operands;
	private final List&lt;String&gt;   groupBy;
	private final Transformation       having;

	private VTLDataSetMetadata metadata;

	public AggrClauseTransformation(List&lt;AggrClauseItem&gt; operands, List&lt;String&gt; groupBy, Transformation having)
<span class="nc" id="L146">	{</span>
<span class="nc" id="L147">		this.operands = operands;</span>
<span class="nc bnc" id="L148" title="All 4 branches missed.">		this.groupBy = groupBy == null || groupBy.isEmpty() ? null : groupBy;</span>
<span class="nc" id="L149">		this.having = having;</span>
<span class="nc" id="L150">	}</span>

	@Override
	public Set&lt;LeafTransformation&gt; getTerminals()
	{
<span class="nc" id="L155">		return operands.stream().map(AggrClauseItem::getOperand).map(Transformation::getTerminals).flatMap(Set::stream).collect(toSet());</span>
	}

	@Override
	public VTLValue eval(TransformationScheme session)
	{
<span class="nc" id="L161">		DataSet operand = (DataSet) getThisValue(session);</span>

<span class="nc" id="L163">		BiFunction&lt;Map&lt;DataStructureComponent&lt;Identifier, ?, ?&gt;, ScalarValue&lt;?, ?, ?&gt;&gt;, Stream&lt;DataPoint&gt;, DataPoint&gt; groupMapper = (keyValues, group) -&gt; {</span>
<span class="nc" id="L164">			LOGGER.trace(&quot;Aggregating group {}&quot;, keyValues);</span>
<span class="nc" id="L165">			List&lt;DataPoint&gt; groupList = group.collect(toList());</span>
<span class="nc" id="L166">			final DataPointBuilder groupResult = new DataPointBuilder(Utils.getStream(operands)</span>
<span class="nc" id="L167">					.map(o -&gt; {</span>
<span class="nc" id="L168">						DataSet groupDataSet = new LightDataSet(operand.getDataStructure(), groupList::stream);</span>
<span class="nc" id="L169">						Optional&lt;DataStructureComponent&lt;?, ?, ?&gt;&gt; found = metadata.getComponent(o.getComponent());</span>
<span class="nc" id="L170">						DataStructureComponent&lt;?, ?, ?&gt; component = found.get();</span>
<span class="nc" id="L171">						ScalarValue&lt;?, ?, ?&gt; value = (ScalarValue&lt;?, ?, ?&gt;) o.getOperand().eval(new ThisScope(groupDataSet, session));</span>

<span class="nc" id="L173">						LOGGER.trace(&quot;Computed {} as {}&quot;, component, value);</span>

<span class="nc" id="L175">						return new SimpleEntry&lt;&gt;(component, value);</span>
<span class="nc" id="L176">					}).collect(entriesToMap()));</span>
<span class="nc" id="L177">			LOGGER.trace(&quot;Aggregated result {}&quot;, groupResult.addAll(keyValues));</span>
<span class="nc" id="L178">			return groupResult.build(metadata);</span>
		};

<span class="nc" id="L181">		return new LightF2DataSet&lt;&gt;(metadata, operand::streamByKeys, metadata.getComponents(Identifier.class), groupMapper);</span>

		/*if (having != null)
		{
			DataSet dsHaving = (DataSet) having.eval(alias + &quot;$having&quot;, new ThisValueEnvironment(result, session).getWrapperSession());
			DataStructureComponent&lt;? extends Measure, BooleanDomainSubset, BooleanDomain&gt; havingResult = dsHaving.getComponents(Measure.class, Domains.BOOLEANDS).iterator().next();

			result = result.filteredMappedJoin(alias, metadata, dsHaving, (a, b) -&gt; ((BooleanValue) b.get(havingResult)).get(), (a, b) -&gt; a);
		}*/

		// return result;
	}

	@Override
	public VTLDataSetMetadata getMetadata(TransformationScheme session)
	{
<span class="nc bnc" id="L197" title="All 2 branches missed.">		if (metadata != null)</span>
<span class="nc" id="L198">			return metadata;</span>

<span class="nc" id="L200">		VTLValueMetadata meta = getThisMetadata(session);</span>

<span class="nc bnc" id="L202" title="All 2 branches missed.">		if (meta instanceof VTLDataSetMetadata)</span>
		{
<span class="nc" id="L204">			VTLDataSetMetadata operand = (VTLDataSetMetadata) meta;</span>

<span class="nc" id="L206">			Set&lt;DataStructureComponent&lt;Identifier, ?, ?&gt;&gt; identifiers = emptySet();</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">			if (groupBy != null)</span>
			{
<span class="nc" id="L209">				Set&lt;DataStructureComponent&lt;?, ?, ?&gt;&gt; groupComps = groupBy.stream()</span>
<span class="nc" id="L210">						.map(operand::getComponent)</span>
<span class="nc" id="L211">						.map(o -&gt; o.orElseThrow(() -&gt; new VTLMissingComponentsException((DataStructure) operand, groupBy.toArray(new String[0]))))</span>
<span class="nc" id="L212">						.collect(toSet());</span>
				
<span class="nc" id="L214">				Optional&lt;DataStructureComponent&lt;?, ?, ?&gt;&gt; nonID = groupComps.stream().filter(c -&gt; c.is(NonIdentifier.class)).findAny();</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">				if (nonID.isPresent())</span>
<span class="nc" id="L216">					throw new VTLIncompatibleRolesException(&quot;aggr with group by&quot;, nonID.get(), Identifier.class);</span>
				
<span class="nc" id="L218">				identifiers = groupComps.stream().map(c -&gt; c.as(Identifier.class)).collect(toSet());</span>
			}

<span class="nc" id="L221">			Builder builder = new Builder().addComponents(identifiers);</span>

<span class="nc bnc" id="L223" title="All 2 branches missed.">			for (AggrClauseItem clause : operands)</span>
			{
<span class="nc" id="L225">				VTLValueMetadata clauseMeta = clause.getOperand().getMetadata(new DatapointScope(null, operand, session));</span>
<span class="nc bnc" id="L226" title="All 4 branches missed.">				if (!(clauseMeta instanceof VTLScalarValueMetadata) || !Domains.NUMBERDS.isAssignableFrom(((VTLScalarValueMetadata&lt;?&gt;) clauseMeta).getDomain()))</span>
<span class="nc" id="L227">					throw new VTLIncompatibleTypesException(&quot;Aggregation&quot;, Domains.NUMBERDS, ((VTLScalarValueMetadata&lt;?&gt;) clauseMeta).getDomain());</span>

<span class="nc" id="L229">				Optional&lt;DataStructureComponent&lt;?,?,?&gt;&gt; maybeExistingComponent = operand.getComponent(clause.getComponent());</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">				Class&lt;? extends ComponentRole&gt; requestedRole = clause.getRole() == null ? Measure.class : clause.getRole();</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">				if (maybeExistingComponent.isPresent())</span>
				{
<span class="nc" id="L233">					DataStructureComponent&lt;?, ?, ?&gt; existingComponent = maybeExistingComponent.get();</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">					if (existingComponent.is(Identifier.class))</span>
<span class="nc" id="L235">						throw new VTLInvariantIdentifiersException(&quot;aggr&quot;, existingComponent.as(Identifier.class), requestedRole);</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">					else if (clause.getRole() == null)</span>
<span class="nc" id="L237">						builder = builder.addComponent(existingComponent);</span>
					else
<span class="nc" id="L239">						builder = builder.addComponent(new DataStructureComponentImpl&lt;&gt;(clause.getComponent(), requestedRole, Domains.NUMBERDS));</span>
<span class="nc" id="L240">				}</span>
				else
<span class="nc" id="L242">					builder = builder.addComponent(new DataStructureComponentImpl&lt;&gt;(clause.getComponent(), requestedRole, Domains.NUMBERDS));</span>
<span class="nc" id="L243">			}</span>

<span class="nc" id="L245">			metadata = builder.build();</span>

<span class="nc bnc" id="L247" title="All 2 branches missed.">			if (having != null)</span>
			{
<span class="nc" id="L249">				throw new UnsupportedOperationException(&quot;HAVING not implemented.&quot;);</span>
//				VTLValueMetadata vHaving = having.getMetadata(new ThisMetaEnvironment(metadata, session).getWrapperSession());
//				if (!(vHaving instanceof VTLDataSetMetadata))
//					throw new VTLSyntaxException(&quot;Having clause must return a dataset.&quot;);
//
//				VTLDataSetMetadata havingDS = (VTLDataSetMetadata) vHaving;
//				if (havingDS.getComponents(Measure.class, Domains.BOOLEANDS).size() != 1)
//					throw new VTLExpectedComponentException(Measure.class, Domains.BOOLEANDS, havingDS.getComponents(Measure.class));
			}

<span class="nc" id="L259">			return metadata;</span>
		}
		else
<span class="nc" id="L262">			throw new VTLInvalidParameterException(meta, VTLDataSetMetadata.class);</span>
	}

	@Override
	public String toString()
	{
<span class="nc bnc" id="L268" title="All 4 branches missed.">		String terminator = (groupBy != null ? groupBy.stream().map(Object::toString).collect(joining(&quot;, &quot;, &quot; group by &quot;, &quot;&quot;)) : &quot;&quot;) + (having != null ? &quot; having &quot; + having : &quot;&quot;);</span>
<span class="nc" id="L269">		return operands.stream().map(Object::toString).collect(joining(&quot;, &quot;, &quot;[aggr &quot;, terminator + &quot;]&quot;));</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CallTransformation.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">vtl-transform</a> &gt; <a href="index.source.html" class="el_package">it.bancaditalia.oss.vtl.impl.transform.ops</a> &gt; <span class="el_source">CallTransformation.java</span></div><h1>CallTransformation.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright 2020, Bank Of Italy
 *
 * Licensed under the EUPL, Version 1.2 (the &quot;License&quot;);
 * You may not use this work except in compliance with the
 * License.
 * You may obtain a copy of the License at:
 *
 * https://joinup.ec.europa.eu/sites/default/files/custom-page/attachment/2020-03/EUPL-1.2%20EN.txt
 *
 * Unless required by applicable law or agreed to in
 * writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; basis,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied.
 *
 * See the License for the specific language governing
 * permissions and limitations under the License.
 *******************************************************************************/
package it.bancaditalia.oss.vtl.impl.transform.ops;

import static java.util.stream.Collectors.toMap;
import static java.util.stream.Collectors.toSet;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.IntStream;

import it.bancaditalia.oss.vtl.engine.NamedOperator;
import it.bancaditalia.oss.vtl.engine.Statement;
import it.bancaditalia.oss.vtl.impl.transform.scope.ParamScope;
import it.bancaditalia.oss.vtl.model.data.VTLValue;
import it.bancaditalia.oss.vtl.model.data.VTLValue.VTLValueMetadata;
import it.bancaditalia.oss.vtl.model.transform.LeafTransformation;
import it.bancaditalia.oss.vtl.model.transform.Transformation;
import it.bancaditalia.oss.vtl.model.transform.TransformationScheme;
import it.bancaditalia.oss.vtl.util.Utils;

public class CallTransformation extends TransformationImpl
{
	private static final long serialVersionUID = 1L;
	private final String operator;
	private final List&lt;Transformation&gt; params;

	public CallTransformation(String operator, List&lt;Transformation&gt; params)
<span class="nc" id="L47">	{</span>
<span class="nc" id="L48">		this.operator = operator;</span>
<span class="nc" id="L49">		this.params = params;</span>
<span class="nc" id="L50">	}</span>

	@Override
	public boolean isTerminal()
	{
<span class="nc" id="L55">		return false;</span>
	}

	@Override
	public Set&lt;LeafTransformation&gt; getTerminals()
	{
<span class="nc" id="L61">		return Utils.getStream(params).map(Transformation::getTerminals).flatMap(Set::stream).collect(toSet());</span>
	}

	@Override
	public VTLValue eval(TransformationScheme scheme)
	{
<span class="nc" id="L67">		Statement statement = scheme.getRule(operator);</span>
<span class="nc bnc" id="L68" title="All 2 branches missed.">		if (statement instanceof NamedOperator)</span>
		{
<span class="nc" id="L70">			NamedOperator op = (NamedOperator) statement;</span>
<span class="nc" id="L71">			List&lt;String&gt; parNames = op.getParameterNames();</span>
<span class="nc" id="L72">			Map&lt;String, Transformation&gt; paramValues = IntStream.range(0, params.size()).boxed()</span>
<span class="nc" id="L73">				.collect(toMap(i -&gt; parNames.get(i), i -&gt; params.get(i)));</span>
<span class="nc" id="L74">			return op.eval(new ParamScope(scheme, paramValues));</span>
		}
		else
<span class="nc" id="L77">			throw new UnsupportedOperationException(&quot;Operator &quot; + operator + &quot; is not defined.&quot;);</span>
	}

	@Override
	public VTLValueMetadata getMetadata(TransformationScheme scheme)
	{
<span class="nc" id="L83">		Statement statement = scheme.getRule(operator);</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">		if (statement instanceof NamedOperator)</span>
		{
<span class="nc" id="L86">			NamedOperator op = (NamedOperator) statement;</span>
<span class="nc" id="L87">			List&lt;String&gt; parNames = op.getParameterNames();</span>
<span class="nc bnc" id="L88" title="All 2 branches missed.">			if (params.size() != parNames.size())</span>
<span class="nc" id="L89">				throw new UnsupportedOperationException(operator + &quot; requires &quot; + parNames.size() + &quot; parameters but &quot; + params.size() + &quot; were provided.&quot;);</span>
<span class="nc" id="L90">			Map&lt;String, Transformation&gt; paramValues = IntStream.range(0, params.size()).boxed()</span>
<span class="nc" id="L91">					.collect(toMap(i -&gt; parNames.get(i), i -&gt; params.get(i)));</span>
<span class="nc" id="L92">			return op.getMetadata(new ParamScope(scheme, paramValues));</span>
		}
		else
<span class="nc" id="L95">			throw new UnsupportedOperationException(&quot;Operator &quot; + operator + &quot; is not defined.&quot;);</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>
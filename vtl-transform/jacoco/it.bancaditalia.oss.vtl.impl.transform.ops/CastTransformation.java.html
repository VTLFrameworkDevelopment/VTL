<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CastTransformation.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">vtl-transform</a> &gt; <a href="index.source.html" class="el_package">it.bancaditalia.oss.vtl.impl.transform.ops</a> &gt; <span class="el_source">CastTransformation.java</span></div><h1>CastTransformation.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright 2020, Bank Of Italy
 *
 * Licensed under the EUPL, Version 1.2 (the &quot;License&quot;);
 * You may not use this work except in compliance with the
 * License.
 * You may obtain a copy of the License at:
 *
 * https://joinup.ec.europa.eu/sites/default/files/custom-page/attachment/2020-03/EUPL-1.2%20EN.txt
 *
 * Unless required by applicable law or agreed to in
 * writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; basis,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied.
 *
 * See the License for the specific language governing
 * permissions and limitations under the License.
 *******************************************************************************/
package it.bancaditalia.oss.vtl.impl.transform.ops;

import static it.bancaditalia.oss.vtl.impl.types.domain.Domains.DATE;
import static it.bancaditalia.oss.vtl.impl.types.domain.Domains.INTEGER;
import static it.bancaditalia.oss.vtl.impl.types.domain.Domains.NUMBER;
import static it.bancaditalia.oss.vtl.impl.types.domain.Domains.STRING;
import static java.time.format.SignStyle.NOT_NEGATIVE;
import static java.time.temporal.ChronoField.DAY_OF_MONTH;
import static java.time.temporal.ChronoField.DAY_OF_WEEK;
import static java.time.temporal.ChronoField.MONTH_OF_YEAR;
import static java.time.temporal.ChronoField.YEAR;
import static java.util.Collections.singletonMap;

import java.text.DecimalFormat;
import java.text.ParseException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeFormatterBuilder;
import java.time.format.DateTimeParseException;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Set;
import java.util.function.UnaryOperator;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import it.bancaditalia.oss.vtl.exceptions.VTLNestedException;
import it.bancaditalia.oss.vtl.impl.transform.exceptions.VTLExpectedComponentException;
import it.bancaditalia.oss.vtl.impl.types.data.DateValue;
import it.bancaditalia.oss.vtl.impl.types.data.DoubleValue;
import it.bancaditalia.oss.vtl.impl.types.data.IntegerValue;
import it.bancaditalia.oss.vtl.impl.types.data.StringValue;
import it.bancaditalia.oss.vtl.impl.types.data.TimeValue;
import it.bancaditalia.oss.vtl.impl.types.dataset.DataStructureComponentImpl;
import it.bancaditalia.oss.vtl.impl.types.dataset.DataStructureImpl;
import it.bancaditalia.oss.vtl.impl.types.domain.Domains;
import it.bancaditalia.oss.vtl.model.data.ComponentRole.Identifier;
import it.bancaditalia.oss.vtl.model.data.ComponentRole.Measure;
import it.bancaditalia.oss.vtl.model.data.DataSet;
import it.bancaditalia.oss.vtl.model.data.DataSet.VTLDataSetMetadata;
import it.bancaditalia.oss.vtl.model.data.DataStructureComponent;
import it.bancaditalia.oss.vtl.model.data.ScalarValue;
import it.bancaditalia.oss.vtl.model.data.ScalarValue.VTLScalarValueMetadata;
import it.bancaditalia.oss.vtl.model.data.VTLValue;
import it.bancaditalia.oss.vtl.model.data.VTLValue.VTLValueMetadata;
import it.bancaditalia.oss.vtl.model.data.ValueDomainSubset;
import it.bancaditalia.oss.vtl.model.domain.DateDomainSubset;
import it.bancaditalia.oss.vtl.model.domain.IntegerDomainSubset;
import it.bancaditalia.oss.vtl.model.domain.NumberDomainSubset;
import it.bancaditalia.oss.vtl.model.domain.StringDomainSubset;
import it.bancaditalia.oss.vtl.model.domain.TimeDomainSubset;
import it.bancaditalia.oss.vtl.model.transform.Transformation;
import it.bancaditalia.oss.vtl.model.transform.TransformationScheme;

public class CastTransformation extends UnaryTransformation
{
	private static final long serialVersionUID = 1L;
<span class="nc" id="L77">	private final static Map&lt;Pattern, UnaryOperator&lt;DateTimeFormatterBuilder&gt;&gt; PATTERNS = new LinkedHashMap&lt;&gt;();</span>
	
	static {
<span class="nc" id="L80">		PATTERNS.put(Pattern.compile(&quot;^(YYYY)(.*)&quot;), b -&gt; b.appendValue(YEAR, 4));</span>
<span class="nc" id="L81">		PATTERNS.put(Pattern.compile(&quot;^(YYY)(.*)$&quot;), b -&gt; b.appendValue(YEAR, 3));</span>
<span class="nc" id="L82">		PATTERNS.put(Pattern.compile(&quot;^(YY)(.*)$&quot;), b -&gt; b.appendValue(YEAR, 2));</span>
<span class="nc" id="L83">		PATTERNS.put(Pattern.compile(&quot;^(M[Oo][Nn][Tt][Hh]3)(.*)$&quot;), b -&gt; b.appendValue(MONTH_OF_YEAR, 3));</span>
<span class="nc" id="L84">		PATTERNS.put(Pattern.compile(&quot;^(M[Oo][Nn][Tt][Hh]1)(.*)$&quot;), b -&gt; b.appendValue(MONTH_OF_YEAR, 5));</span>
<span class="nc" id="L85">		PATTERNS.put(Pattern.compile(&quot;^(D[Aa][Yy]3)(.*)$&quot;), b -&gt; b.appendValue(DAY_OF_WEEK, 3));</span>
<span class="nc" id="L86">		PATTERNS.put(Pattern.compile(&quot;^(D[Aa][Yy]1)(.*)$&quot;), b -&gt; b.appendValue(DAY_OF_WEEK, 5));</span>
<span class="nc" id="L87">		PATTERNS.put(Pattern.compile(&quot;^(MM)(.*)$&quot;), b -&gt; b.appendValue(MONTH_OF_YEAR, 2));</span>
<span class="nc" id="L88">		PATTERNS.put(Pattern.compile(&quot;^(M)(.*)$&quot;), b -&gt; b.appendValue(MONTH_OF_YEAR, 1, 2, NOT_NEGATIVE));</span>
<span class="nc" id="L89">		PATTERNS.put(Pattern.compile(&quot;^(DD)(.*)$&quot;), b -&gt; b.appendValue(DAY_OF_MONTH, 2));</span>
<span class="nc" id="L90">		PATTERNS.put(Pattern.compile(&quot;^(D)(.*)$&quot;), b -&gt; b.appendValue(DAY_OF_MONTH, 1, 2, NOT_NEGATIVE));</span>
<span class="nc" id="L91">		PATTERNS.put(Pattern.compile(&quot;^(-)(.*)$&quot;), b -&gt; b.appendLiteral(&quot;-&quot;));</span>
<span class="nc" id="L92">		PATTERNS.put(Pattern.compile(&quot;^(/)(.*)$&quot;), b -&gt; b.appendLiteral(&quot;/&quot;));</span>
<span class="nc" id="L93">		PATTERNS.put(Pattern.compile(&quot;^( )(.*)$&quot;), b -&gt; b.appendLiteral(&quot; &quot;));</span>
<span class="nc" id="L94">	}</span>
	
	private final ValueDomainSubset&lt;?&gt; target;
	private final String mask;
	private transient DateTimeFormatter dateTimeFormatter;
	private transient DecimalFormat numberFormatter;

	public CastTransformation(Transformation operand, Domains target, String mask)
	{
<span class="nc" id="L103">		super(operand);</span>
<span class="nc" id="L104">		this.target = target.getDomain();</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">		this.mask = mask != null ? mask.substring(1, mask.length() - 1) : &quot;&quot;;</span>
<span class="nc" id="L106">	}</span>

	public CastTransformation(Transformation operand, String targetDomainName, String mask)
	{
<span class="nc" id="L110">		super(null);</span>
<span class="nc" id="L111">		throw new UnsupportedOperationException(&quot;cast with non-basic domain names not implemented&quot;);</span>
	}

	@Override
	protected VTLValue evalOnScalar(ScalarValue&lt;?, ?, ?&gt; scalar)
	{
<span class="nc" id="L117">		return castScalar(scalar);</span>
	}

	@Override
	protected VTLValue evalOnDataset(DataSet dataset)
	{
<span class="nc" id="L123">		DataStructureComponent&lt;Measure, ?, ?&gt; oldMeasure = dataset.getComponents(Measure.class).iterator().next();</span>
<span class="nc" id="L124">		DataStructureComponent&lt;Measure, ?, ?&gt; measure = new DataStructureComponentImpl&lt;&gt;(target.getVarName(), Measure.class, target);</span>
<span class="nc" id="L125">		VTLDataSetMetadata structure = new DataStructureImpl.Builder(dataset.getComponents(Identifier.class))</span>
<span class="nc" id="L126">				.addComponent(measure)</span>
<span class="nc" id="L127">				.build();</span>
<span class="nc" id="L128">		return dataset.mapKeepingKeys(structure, dp -&gt; singletonMap(measure, castScalar(dp.get(oldMeasure))));</span>
	}

	@Override
	public VTLValueMetadata getMetadata(TransformationScheme session)
	{
<span class="nc" id="L134">		VTLValueMetadata meta = operand.getMetadata(session);</span>
		ValueDomainSubset&lt;?&gt; domain;
		
<span class="nc bnc" id="L137" title="All 2 branches missed.">		if (meta instanceof VTLScalarValueMetadata)</span>
<span class="nc" id="L138">			domain = ((VTLScalarValueMetadata&lt;?&gt;) meta).getDomain();</span>
		else
		{
<span class="nc" id="L141">			VTLDataSetMetadata dataset = (VTLDataSetMetadata) meta;</span>
			
<span class="nc" id="L143">			Set&lt;? extends DataStructureComponent&lt;? extends Measure, ?, ?&gt;&gt; measures = dataset.getComponents(Measure.class);</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">			if (measures.size() != 1)</span>
<span class="nc" id="L145">				throw new VTLExpectedComponentException(Measure.class, measures);</span>
			
<span class="nc" id="L147">			DataStructureComponent&lt;? extends Measure, ?, ?&gt; measure = measures.iterator().next();</span>
			
			// keep the ordering! DateDomain subclass of TimeDomain, IntegerDomain subclass of NumberDomain
<span class="nc" id="L150">			domain = measure.getDomain();</span>
		}

<span class="nc bnc" id="L153" title="All 4 branches missed.">		if (domain instanceof StringDomainSubset &amp;&amp; target instanceof DateDomainSubset)</span>
<span class="nc" id="L154">			return DATE;</span>
//			else if (scalarmeta.getDomain() instanceof StringDomainSubset &amp;&amp; target instanceof TimeDomainSubset)
//				return TIME;
<span class="nc bnc" id="L157" title="All 4 branches missed.">		else if (domain instanceof StringDomainSubset &amp;&amp; target instanceof IntegerDomainSubset)</span>
<span class="nc" id="L158">			return INTEGER;</span>
<span class="nc bnc" id="L159" title="All 4 branches missed.">		else if (domain instanceof StringDomainSubset &amp;&amp; target instanceof NumberDomainSubset)</span>
<span class="nc" id="L160">			return NUMBER;</span>
<span class="nc bnc" id="L161" title="All 4 branches missed.">		else if (domain instanceof TimeDomainSubset &amp;&amp; target instanceof StringDomainSubset)</span>
<span class="nc" id="L162">			return STRING;</span>
<span class="nc bnc" id="L163" title="All 4 branches missed.">		else if (domain instanceof TimeDomainSubset &amp;&amp; target instanceof TimeDomainSubset)</span>
<span class="nc" id="L164">			return (VTLScalarValueMetadata&lt;?&gt;) () -&gt; target;</span>
//			else if (scalarmeta.getDomain() instanceof TimeDomainSubset &amp;&amp; target instanceof StringDomainSubset)
//				return STRING;
		else
<span class="nc" id="L168">			throw new UnsupportedOperationException();</span>
	}

	private synchronized DecimalFormat getNumberFormatter()
	{
<span class="nc bnc" id="L173" title="All 2 branches missed.">		if (numberFormatter != null)</span>
<span class="nc" id="L174">			return numberFormatter;</span>
		
<span class="nc" id="L176">		synchronized (this)</span>
		{
<span class="nc bnc" id="L178" title="All 2 branches missed.">			if (numberFormatter != null)</span>
<span class="nc" id="L179">				return numberFormatter;</span>
			
<span class="nc" id="L181">			return numberFormatter = new DecimalFormat(mask);</span>
		}
	}

	private synchronized DateTimeFormatter getDateFormatter()
	{
<span class="nc bnc" id="L187" title="All 2 branches missed.">		if (dateTimeFormatter != null)</span>
<span class="nc" id="L188">			return dateTimeFormatter;</span>
		
<span class="nc" id="L190">		synchronized (this)</span>
		{
<span class="nc bnc" id="L192" title="All 2 branches missed.">			if (dateTimeFormatter != null)</span>
<span class="nc" id="L193">				return dateTimeFormatter;</span>
			
<span class="nc" id="L195">			DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();</span>
<span class="nc" id="L196">			String maskRemaining = mask;</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">			while (!maskRemaining.isEmpty())</span>
			{
<span class="nc" id="L199">				boolean found = false;</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">				for (Pattern pattern: PATTERNS.keySet())</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">					if (!found)</span>
					{
<span class="nc" id="L203">						Matcher matcher = pattern.matcher(maskRemaining);</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">						if (matcher.find())</span>
						{
<span class="nc" id="L206">							builder = PATTERNS.get(pattern).apply(builder);</span>
<span class="nc" id="L207">							maskRemaining = matcher.group(2);</span>
<span class="nc" id="L208">							found = true;</span>
						}
					}
				
<span class="nc bnc" id="L212" title="All 2 branches missed.">				if (!found)</span>
<span class="nc" id="L213">					throw new IllegalStateException(&quot;Unrecognized mask characters in cast operator: &quot; + maskRemaining);</span>
<span class="nc" id="L214">			}</span>
			
<span class="nc" id="L216">			return dateTimeFormatter = builder.toFormatter();</span>
		}
	}

	private ScalarValue&lt;?, ?, ?&gt; castScalar(ScalarValue&lt;?, ?, ?&gt; scalar)
	{
		try
		{
<span class="nc bnc" id="L224" title="All 4 branches missed.">			if (scalar instanceof StringValue &amp;&amp; target instanceof DateDomainSubset)</span>
<span class="nc" id="L225">				return new DateValue(LocalDateTime.parse((String) scalar.get(), getDateFormatter()));</span>
//				else if (scalar instanceof StringValue &amp;&amp; target instanceof TimeDomainSubset)
//					return new TimeValue(LocalTime.parse((String) scalar.get(), mask));
<span class="nc bnc" id="L228" title="All 4 branches missed.">			else if (scalar instanceof StringValue &amp;&amp; target instanceof IntegerDomainSubset)</span>
<span class="nc" id="L229">				return new IntegerValue(Long.parseLong((String) scalar.get()));</span>
<span class="nc bnc" id="L230" title="All 4 branches missed.">			else if (scalar instanceof StringValue &amp;&amp; target instanceof NumberDomainSubset)</span>
<span class="nc" id="L231">				return new DoubleValue(getNumberFormatter().parse((String) scalar.get()).doubleValue());</span>
<span class="nc bnc" id="L232" title="All 4 branches missed.">			else if (scalar instanceof TimeValue &amp;&amp; target instanceof TimeDomainSubset)</span>
<span class="nc" id="L233">				return target.cast(scalar);</span>
<span class="nc bnc" id="L234" title="All 4 branches missed.">			else if (scalar instanceof TimeValue &amp;&amp; target instanceof StringDomainSubset)</span>
<span class="nc" id="L235">				return new StringValue(getDateFormatter().format(((TimeValue&lt;?, ?, ?&gt;) scalar).get()));</span>
//				else if (scalar instanceof TimeValueImpl &amp;&amp; target instanceof StringDomainSubset)
//					return new StringValue(dateFormatter.format((LocalTime) scalar.get()));
			else
<span class="nc" id="L239">				throw new UnsupportedOperationException(scalar.getClass() + &quot; &quot; + target.getClass() + &quot; &quot; + scalar);</span>
		}
<span class="nc" id="L241">		catch (DateTimeParseException e)</span>
		{
<span class="nc" id="L243">			throw new VTLNestedException(&quot;Date/time '&quot; + scalar.get() + &quot;' unparseable with mask '&quot; + getDateFormatter() + &quot;'&quot;, e);</span>
		}
<span class="nc" id="L245">		catch (ParseException e)</span>
		{
<span class="nc" id="L247">			throw new VTLNestedException(&quot;Number '&quot; + scalar.get() + &quot;' unparseable with mask '&quot; + getNumberFormatter() + &quot;'&quot;, e);</span>
		}
	}
	
	@Override
	public String toString()
	{
<span class="nc" id="L254">		return &quot;cast(&quot; + operand + &quot;, &quot; + target + &quot;, \&quot;&quot; + mask + &quot;\&quot;)&quot;;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ConcatTransformation.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">vtl-transform</a> &gt; <a href="index.source.html" class="el_package">it.bancaditalia.oss.vtl.impl.transform.ops</a> &gt; <span class="el_source">ConcatTransformation.java</span></div><h1>ConcatTransformation.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright 2020, Bank Of Italy
 *
 * Licensed under the EUPL, Version 1.2 (the &quot;License&quot;);
 * You may not use this work except in compliance with the
 * License.
 * You may obtain a copy of the License at:
 *
 * https://joinup.ec.europa.eu/sites/default/files/custom-page/attachment/2020-03/EUPL-1.2%20EN.txt
 *
 * Unless required by applicable law or agreed to in
 * writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; basis,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied.
 *
 * See the License for the specific language governing
 * permissions and limitations under the License.
 *******************************************************************************/
package it.bancaditalia.oss.vtl.impl.transform.ops;

import static it.bancaditalia.oss.vtl.impl.types.domain.Domains.STRINGDS;
import static it.bancaditalia.oss.vtl.util.Utils.reverseIfBOp;

import java.util.AbstractMap.SimpleEntry;
import java.util.Collections;
import java.util.Set;
import java.util.function.BinaryOperator;

import it.bancaditalia.oss.vtl.exceptions.VTLException;
import it.bancaditalia.oss.vtl.impl.transform.exceptions.VTLExpectedComponentException;
import it.bancaditalia.oss.vtl.impl.types.data.NullValue;
import it.bancaditalia.oss.vtl.impl.types.data.StringValue;
import it.bancaditalia.oss.vtl.impl.types.dataset.DataPointImpl.DataPointBuilder;
import it.bancaditalia.oss.vtl.impl.types.dataset.DataStructureImpl.Builder;
import it.bancaditalia.oss.vtl.impl.types.domain.Domains;
import it.bancaditalia.oss.vtl.impl.types.exceptions.VTLIncompatibleTypesException;
import it.bancaditalia.oss.vtl.impl.types.exceptions.VTLSingletonComponentRequiredException;
import it.bancaditalia.oss.vtl.model.data.ComponentRole.Identifier;
import it.bancaditalia.oss.vtl.model.data.ComponentRole.Measure;
import it.bancaditalia.oss.vtl.model.data.DataSet;
import it.bancaditalia.oss.vtl.model.data.DataSet.VTLDataSetMetadata;
import it.bancaditalia.oss.vtl.model.data.DataStructureComponent;
import it.bancaditalia.oss.vtl.model.data.ScalarValue;
import it.bancaditalia.oss.vtl.model.data.ScalarValue.VTLScalarValueMetadata;
import it.bancaditalia.oss.vtl.model.data.VTLValue;
import it.bancaditalia.oss.vtl.model.data.VTLValue.VTLValueMetadata;
import it.bancaditalia.oss.vtl.model.domain.StringDomain;
import it.bancaditalia.oss.vtl.model.domain.StringDomainSubset;
import it.bancaditalia.oss.vtl.model.transform.Transformation;
import it.bancaditalia.oss.vtl.model.transform.TransformationScheme;
import it.bancaditalia.oss.vtl.util.Utils;

public class ConcatTransformation extends BinaryTransformation
{
	private static final long serialVersionUID = 1L;
<span class="pc bpc" id="L57" title="1 of 4 branches missed.">	private final static BinaryOperator&lt;ScalarValue&lt;?, ? extends StringDomainSubset, ? extends StringDomain&gt;&gt; concat = (l, r) -&gt; l instanceof NullValue || r instanceof NullValue </span>
<span class="fc" id="L58">			? NullValue.instance(STRINGDS)</span>
<span class="fc" id="L59">			: new StringValue(l.get().toString() + r.get().toString());</span>

	public ConcatTransformation(Transformation left, Transformation right)
	{
<span class="fc" id="L63">		super(left, right);</span>
<span class="fc" id="L64">	}</span>

<span class="fc" id="L66">	private VTLDataSetMetadata metadata = null;</span>

	@Override
	protected VTLValue evalTwoScalars(ScalarValue&lt;?, ?, ?&gt; left, ScalarValue&lt;?, ?, ?&gt; right)
	{
<span class="nc" id="L71">		return concat.apply((StringValue) STRINGDS.cast(left), (StringValue) STRINGDS.cast(right));</span>
	}

	@Override
	protected VTLValue evalDatasetWithScalar(boolean datasetIsLeftOp, DataSet dataset, ScalarValue&lt;?, ?, ?&gt; scalar)
	{
<span class="nc bnc" id="L77" title="All 2 branches missed.">		BinaryOperator&lt;ScalarValue&lt;?, ? extends StringDomainSubset, ? extends StringDomain&gt;&gt; function = Utils.reverseIfBOp(!datasetIsLeftOp, concat);</span>
<span class="nc" id="L78">		VTLDataSetMetadata structure = dataset.getDataStructure();</span>
<span class="nc" id="L79">		DataStructureComponent&lt;Measure, StringDomainSubset, StringDomain&gt; measure = structure.getComponents(Measure.class, Domains.STRINGDS).iterator().next();</span>
		
<span class="nc" id="L81">		return dataset.mapKeepingKeys(structure, dp -&gt; Collections.singletonMap(measure, </span>
<span class="nc" id="L82">				function.apply(STRINGDS.cast(dp.get(measure)), STRINGDS.cast(scalar)))); </span>
	}

	@Override
	protected VTLValue evalTwoDatasets(DataSet left, DataSet right)
	{
<span class="fc" id="L88">		boolean leftHasMoreIdentifiers = left.getComponents(Identifier.class).containsAll(right.getComponents(Identifier.class));</span>

<span class="pc bpc" id="L90" title="1 of 2 branches missed.">		DataSet streamed = leftHasMoreIdentifiers ? right: left;</span>
<span class="pc bpc" id="L91" title="1 of 2 branches missed.">		DataSet indexed = leftHasMoreIdentifiers ? left: right;</span>
<span class="fc" id="L92">		Set&lt;? extends DataStructureComponent&lt;? extends Measure, ?, ?&gt;&gt; resultMeasures = metadata.getComponents(Measure.class);</span>
		
		// must remember which is the left operand because some operators are not commutative
<span class="pc bpc" id="L95" title="1 of 2 branches missed.">		BinaryOperator&lt;ScalarValue&lt;?, ? extends StringDomainSubset, ? extends StringDomain&gt;&gt; finalOperator = reverseIfBOp(!leftHasMoreIdentifiers, concat);  </span>

		// Scan the dataset with less identifiers and find the matches
<span class="fc" id="L98">		return indexed.filteredMappedJoin(metadata, streamed, (dp1, dp2) -&gt; true /* no filter */,</span>
<span class="fc" id="L99">			(dp1, dp2) -&gt; new DataPointBuilder(resultMeasures.stream()</span>
<span class="fc" id="L100">					.map(rm -&gt; new SimpleEntry&lt;&gt;(rm, finalOperator</span>
<span class="fc" id="L101">							.apply(STRINGDS.cast(dp1.get(indexed.getComponent(rm.getName()).get())), </span>
<span class="fc" id="L102">									STRINGDS.cast(dp2.get(streamed.getComponent(rm.getName()).get())))))</span>
<span class="fc" id="L103">					.collect(Utils.entriesToMap()))		</span>
<span class="fc" id="L104">				.addAll(dp1.getValues(Identifier.class))</span>
<span class="fc" id="L105">				.addAll(dp2.getValues(Identifier.class))</span>
<span class="fc" id="L106">				.build(metadata));</span>
	}

	@Override
	public VTLValueMetadata getMetadata(TransformationScheme session)
	{
<span class="fc" id="L112">		VTLValueMetadata left = leftOperand.getMetadata(session), right = rightOperand.getMetadata(session);</span>
		
<span class="pc bpc" id="L114" title="3 of 4 branches missed.">		if (left instanceof VTLScalarValueMetadata &amp;&amp; right instanceof VTLScalarValueMetadata)</span>
		{
<span class="nc" id="L116">			VTLScalarValueMetadata&lt;?&gt; leftV = (VTLScalarValueMetadata&lt;?&gt;) left, rightV = (VTLScalarValueMetadata&lt;?&gt;) right; </span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">			if (!(STRINGDS.isAssignableFrom(leftV.getDomain())))</span>
<span class="nc" id="L118">				throw new VTLIncompatibleTypesException(&quot;concat&quot;, STRINGDS, leftV.getDomain());</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">			else if (!(STRINGDS.isAssignableFrom(rightV.getDomain())))</span>
<span class="nc" id="L120">				throw new VTLIncompatibleTypesException(&quot;concat&quot;, STRINGDS, rightV.getDomain());</span>
			else
<span class="nc" id="L122">				return (VTLScalarValueMetadata&lt;StringDomainSubset&gt;) () -&gt; STRINGDS;</span>
		}
<span class="pc bpc" id="L124" title="2 of 4 branches missed.">		else if (left instanceof VTLScalarValueMetadata || right instanceof VTLScalarValueMetadata)</span>
		{
<span class="nc" id="L126">			boolean leftIsScalar = left instanceof VTLScalarValueMetadata;</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">			VTLScalarValueMetadata&lt;?&gt; value = leftIsScalar ? (VTLScalarValueMetadata&lt;?&gt;) left : (VTLScalarValueMetadata&lt;?&gt;) right;</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">			VTLDataSetMetadata metadata = leftIsScalar ? (VTLDataSetMetadata) left : (VTLDataSetMetadata) right;</span>
			
<span class="nc bnc" id="L130" title="All 2 branches missed.">			if (!STRINGDS.isAssignableFrom(value.getDomain()))</span>
<span class="nc" id="L131">				throw new VTLIncompatibleTypesException(&quot;concat&quot;, STRINGDS, value.getDomain());</span>
			
<span class="nc" id="L133">			final Set&lt;? extends DataStructureComponent&lt;? extends Measure, ?, ?&gt;&gt; measures = metadata.getComponents(Measure.class);</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">			if (measures.size() != 1)</span>
<span class="nc" id="L135">				throw new VTLSingletonComponentRequiredException(Measure.class, measures);</span>
			
<span class="nc" id="L137">			DataStructureComponent&lt;? extends Measure, ?, ?&gt; measure = measures.iterator().next();</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">			if (!STRINGDS.isAssignableFrom(measure.getDomain()))</span>
<span class="nc" id="L139">				throw new VTLExpectedComponentException(Measure.class, STRINGDS, measures);</span>
			
<span class="nc" id="L141">			return metadata;</span>
		}
		else {
<span class="fc" id="L144">			VTLDataSetMetadata leftD = (VTLDataSetMetadata) left, rightD = (VTLDataSetMetadata) right;</span>
			
<span class="fc" id="L146">			Set&lt;? extends DataStructureComponent&lt;? extends Identifier, ?, ?&gt;&gt; leftIds = leftD.getComponents(Identifier.class);</span>
<span class="fc" id="L147">			Set&lt;? extends DataStructureComponent&lt;? extends Identifier, ?, ?&gt;&gt; rightIds = rightD.getComponents(Identifier.class);</span>

<span class="pc bpc" id="L149" title="3 of 4 branches missed.">			if (!leftIds.containsAll(rightIds) &amp;&amp; !rightIds.containsAll(leftIds))</span>
<span class="nc" id="L150">				throw new VTLException(&quot;One dataset must have at least all the identifiers of the other.&quot;);</span>
			
<span class="fc" id="L152">			Set&lt;? extends DataStructureComponent&lt;? extends Measure, ?, ?&gt;&gt; leftMeasures = leftD.getComponents(Measure.class);</span>
<span class="fc" id="L153">			Set&lt;? extends DataStructureComponent&lt;? extends Measure, ?, ?&gt;&gt; rightMeasures = rightD.getComponents(Measure.class);</span>
			
<span class="pc bpc" id="L155" title="1 of 2 branches missed.">			if (!leftMeasures.equals(rightMeasures))</span>
<span class="nc" id="L156">				throw new VTLException(&quot;The two datasets must have the same measures.&quot;);</span>
			
<span class="fc" id="L158">			leftMeasures.stream()</span>
<span class="fc" id="L159">					.forEach(m -&gt; {</span>
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">						if (!STRINGDS.isAssignableFrom(m.getDomain()))</span>
<span class="nc" id="L161">							throw new VTLIncompatibleTypesException(&quot;concat&quot;, STRINGDS, m.getDomain());</span>
<span class="fc" id="L162">					});</span>
			
<span class="fc" id="L164">			return metadata = new Builder()</span>
<span class="fc" id="L165">					.addComponents(leftIds)</span>
<span class="fc" id="L166">					.addComponents(rightIds)</span>
<span class="fc" id="L167">					.addComponents(leftMeasures)</span>
<span class="fc" id="L168">					.build();</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>StatementFactory.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">vtl-coverage</a> &gt; <a href="../index.html" class="el_bundle">vtl-engine</a> &gt; <a href="index.source.html" class="el_package">it.bancaditalia.oss.vtl.impl.engine.statement</a> &gt; <span class="el_source">StatementFactory.java</span></div><h1>StatementFactory.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright 2020, Bank Of Italy
 *
 * Licensed under the EUPL, Version 1.2 (the &quot;License&quot;);
 * You may not use this work except in compliance with the
 * License.
 * You may obtain a copy of the License at:
 *
 * https://joinup.ec.europa.eu/sites/default/files/custom-page/attachment/2020-03/EUPL-1.2%20EN.txt
 *
 * Unless required by applicable law or agreed to in
 * writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; basis,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied.
 *
 * See the License for the specific language governing
 * permissions and limitations under the License.
 *******************************************************************************/
package it.bancaditalia.oss.vtl.impl.engine.statement;

import static it.bancaditalia.oss.vtl.util.Utils.coalesce;
import static java.util.Collections.emptyList;

import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;
import java.util.stream.Collectors;

import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.RuleContext;
import org.antlr.v4.runtime.Token;
import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.tree.TerminalNode;

import it.bancaditalia.oss.vtl.engine.Statement;
import it.bancaditalia.oss.vtl.grammar.Vtl;
import it.bancaditalia.oss.vtl.grammar.Vtl.ComponentTypeContext;
import it.bancaditalia.oss.vtl.grammar.Vtl.DefOperatorContext;
import it.bancaditalia.oss.vtl.grammar.Vtl.DefOperatorsContext;
import it.bancaditalia.oss.vtl.grammar.Vtl.DefineExpressionContext;
import it.bancaditalia.oss.vtl.grammar.Vtl.InputParameterTypeContext;
import it.bancaditalia.oss.vtl.grammar.Vtl.OutputParameterTypeContext;
import it.bancaditalia.oss.vtl.grammar.Vtl.ParameterItemContext;
import it.bancaditalia.oss.vtl.grammar.Vtl.PersistAssignmentContext;
import it.bancaditalia.oss.vtl.grammar.Vtl.ScalarTypeContext;
import it.bancaditalia.oss.vtl.grammar.Vtl.StatementContext;
import it.bancaditalia.oss.vtl.grammar.Vtl.TemporaryAssignmentContext;
import it.bancaditalia.oss.vtl.impl.engine.exceptions.VTLUnmappedContextException;
import it.bancaditalia.oss.vtl.impl.engine.mapping.OpsFactory;
import it.bancaditalia.oss.vtl.model.data.ComponentRole;
import it.bancaditalia.oss.vtl.model.data.ComponentRole.Attribute;
import it.bancaditalia.oss.vtl.model.data.ComponentRole.Identifier;
import it.bancaditalia.oss.vtl.model.data.ComponentRole.Measure;
import it.bancaditalia.oss.vtl.model.data.ComponentRole.ViralAttribute;
import it.bancaditalia.oss.vtl.model.transform.Transformation;

public class StatementFactory
{
	private final OpsFactory opsFactory;

	public StatementFactory(OpsFactory opsFactory)
<span class="nc" id="L64">	{</span>
<span class="nc" id="L65">		this.opsFactory = opsFactory;</span>
<span class="nc" id="L66">	}</span>

	public Statement createStatement(StatementContext ctx) throws IllegalArgumentException, IllegalAccessException, NoSuchFieldException, SecurityException, InvocationTargetException, NoSuchMethodException, ClassNotFoundException, InstantiationException
	{
<span class="nc bnc" id="L70" title="All 2 branches missed.">		if (ctx instanceof TemporaryAssignmentContext)</span>
		{
<span class="nc" id="L72">			TemporaryAssignmentContext asc = (TemporaryAssignmentContext) ctx;</span>
<span class="nc" id="L73">			return new AssignStatement(asc.varID().getText(), buildExpr(asc.expr()), false);</span>
		}
<span class="nc bnc" id="L75" title="All 2 branches missed.">		else if (ctx instanceof PersistAssignmentContext)</span>
		{
<span class="nc" id="L77">			PersistAssignmentContext asc = (PersistAssignmentContext) ctx;</span>
<span class="nc" id="L78">			return new AssignStatement(asc.varID().getText(), buildExpr(asc.expr()), true);</span>
		}
//		else if (node instanceof DefineExpressionContext)
//		{
//			DefHierarchicalContext dhc = ((DefineHierarchicalStatementContext) node).defHierarchical();
//			String name = dhc.rulesetID().getText();
//			boolean isValueDomain = dhc.hierRuleSignature().VALUE_DOMAIN() != null; 
//			String item = dhc.hierRuleSignature().ruleName.getText(); 
//			Map&lt;String, String&gt; conditions = dhc.hierRuleSignature().conditioningItem() == null ? Collections.emptyMap() 
//					: dhc.hierRuleSignature().conditioningItem().stream()
//						.collect(toMap(i -&gt; i.cond.getText(), i -&gt; i.alias != null ? i.alias.getText() : i.cond.getText()));
//			
//			List&lt;RuleItemImpl&gt; rules = dhc.ruleClauseHierarchical().ruleItemHierarchical().stream()
//				.map(rihc -&gt; new RuleItemImpl(rihc.codeItemRelation().IDENTIFIER().getText(),
//						mapCO(rihc.codeItemRelation().opComp),
//						rihc.codeItemRelation().codeItemRelationClause().stream()
//							.map(circ -&gt; new SourceItemImpl(circ.IDENTIFIER().getText(), circ.DASH() == null, buildExpr(circ.expr())))
//							.collect(toList()),
//						buildExpr(rihc.codeItemRelation().expr()), buildExpr(rihc.erCode().constant()), buildExpr(rihc.erLevel())))
//				.collect(toList());
//			
//			return new DefineHierarchyStatement(name, item, isValueDomain, conditions, rules);
//		}
		else
		{
<span class="nc" id="L103">			DefOperatorsContext defineContext = ((DefineExpressionContext) ctx).defOperators();</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">			if (defineContext instanceof DefOperatorContext)</span>
			{
<span class="nc" id="L106">				DefOperatorContext defineOp = (DefOperatorContext) defineContext;</span>
<span class="nc" id="L107">				List&lt;Parameter&gt; params = coalesce(defineOp.parameterItem(), emptyList()).stream()</span>
<span class="nc" id="L108">						.map(this::buildParam)</span>
<span class="nc" id="L109">						.collect(Collectors.toList());</span>
<span class="nc" id="L110">				String outputType = buildParamType(defineOp.outputParameterType());</span>
				
<span class="nc" id="L112">				return new DefineOperatorStatement(defineOp.operatorID().getText(), params, outputType, buildExpr(defineOp.expr()));</span>
			}
			else
<span class="nc" id="L115">				throw new VTLUnmappedContextException(ctx);</span>
		}
	}

	private Transformation buildExpr(ParserRuleContext ctx) throws IllegalArgumentException, IllegalAccessException, NoSuchFieldException, SecurityException, InvocationTargetException, NoSuchMethodException, ClassNotFoundException, InstantiationException
	{
<span class="nc" id="L121">		return opsFactory.buildExpr(ctx);</span>
	}

	public Parameter buildParam(ParameterItemContext param)
	{
<span class="nc" id="L126">		return buildParamType(param.varID().getText(), param.inputParameterType());</span>
//		
//		if (String.class == buildParamType.getValue())
//			return new ScalarParameter(, buildParamType.getKey());
//		else
//			throw new UnsupportedOperationException(&quot;Parameter type not implemented: &quot; + param.inputParameterType().getText());
	}

	private Parameter buildParamType(String name, ParserRuleContext type)
	{
<span class="nc" id="L136">		ScalarTypeContext scalarType = null;</span>
<span class="nc" id="L137">		ComponentTypeContext compType = null;</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">		if (type instanceof InputParameterTypeContext)</span>
		{
<span class="nc" id="L140">			InputParameterTypeContext inputParameterTypeContext = (InputParameterTypeContext) type;</span>
<span class="nc" id="L141">			scalarType = inputParameterTypeContext.scalarType();</span>
<span class="nc" id="L142">			compType = inputParameterTypeContext.componentType();</span>
<span class="nc" id="L143">		}</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">		else if (type instanceof ScalarTypeContext)</span>
		{
<span class="nc" id="L146">			scalarType = (ScalarTypeContext) type;</span>
		}
		else
<span class="nc" id="L149">			throw new UnsupportedOperationException(type.getClass().getName());</span>
		
<span class="nc bnc" id="L151" title="All 2 branches missed.">		if (scalarType != null)</span>
		{
<span class="nc" id="L153">			ParserRuleContext scalarTypeName = coalesce(scalarType.basicScalarType(), scalarType.valueDomainName());</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">			if (scalarType.scalarTypeConstraint() != null)</span>
<span class="nc" id="L155">				throw new UnsupportedOperationException(&quot;Domain constraint not implemented.&quot;);</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">			if (scalarType.NULL_CONSTANT() != null)</span>
<span class="nc" id="L157">				throw new UnsupportedOperationException(&quot;NULL/NOT NULL constraint not implemented.&quot;);</span>
<span class="nc" id="L158">			return new ScalarParameter(name, scalarTypeName.getText());</span>
		}
<span class="nc bnc" id="L160" title="All 2 branches missed.">		else if (compType != null)</span>
		{
<span class="nc" id="L162">			String domain = null;</span>
<span class="nc" id="L163">			scalarType = compType.scalarType();</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">			if (scalarType != null)</span>
<span class="nc" id="L165">				domain = ((ScalarParameter) buildParamType(name, scalarType)).getDomain();</span>

<span class="nc" id="L167">			ParseTree roleCtx = compType.componentRole();</span>
<span class="nc" id="L168">			Stack&lt;ParseTree&gt; stack = new Stack&lt;&gt;();</span>
<span class="nc" id="L169">			List&lt;Token&gt; resultList = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L170">			stack.push(roleCtx);</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">			while (!stack.isEmpty())</span>
			{
<span class="nc" id="L173">				ParseTree current = stack.pop();</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">				if (current instanceof TerminalNode)</span>
<span class="nc" id="L175">					resultList.add((Token) current.getPayload());</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">				else if (current instanceof RuleContext)</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">					for (int i = 0; i &lt; current.getChildCount(); i++)</span>
<span class="nc" id="L178">						stack.push(current.getChild(i));</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">				else if (current != null)</span>
<span class="nc" id="L180">					throw new IllegalStateException(&quot;Unexpected ParseTree of &quot; + current.getClass());</span>
<span class="nc" id="L181">			}</span>

			Class&lt;? extends ComponentRole&gt; role;
<span class="nc bnc" id="L184" title="All 2 branches missed.">			if (resultList.size() == 0)</span>
<span class="nc" id="L185">				role = null;</span>
<span class="nc bnc" id="L186" title="All 4 branches missed.">			else if (resultList.size() == 1 &amp;&amp; resultList.get(0).getType() == Vtl.MEASURE)</span>
<span class="nc" id="L187">				role = Measure.class;</span>
<span class="nc bnc" id="L188" title="All 4 branches missed.">			else if (resultList.size() == 1 &amp;&amp; resultList.get(0).getType() == Vtl.DIMENSION)</span>
<span class="nc" id="L189">				role = Identifier.class;</span>
<span class="nc bnc" id="L190" title="All 4 branches missed.">			else if (resultList.size() == 1 &amp;&amp; resultList.get(0).getType() == Vtl.ATTRIBUTE)</span>
<span class="nc" id="L191">				role = Attribute.class;</span>
<span class="nc bnc" id="L192" title="All 6 branches missed.">			else if (resultList.size() == 2 &amp;&amp; resultList.get(0).getType() == Vtl.VIRAL &amp;&amp; resultList.get(1).getType() == Vtl.ATTRIBUTE)</span>
<span class="nc" id="L193">				role = ViralAttribute.class;</span>
			else
			{
<span class="nc" id="L196">				Token token = resultList.get(0);</span>
<span class="nc" id="L197">				throw new IllegalStateException(&quot;Unrecognized role token &quot; + Vtl.VOCABULARY.getSymbolicName(token.getType()) + &quot; containing &quot; + token.getText());</span>
			}
			
<span class="nc" id="L200">			return new ComponentParameter&lt;&gt;(name, domain, role);</span>
		}
		else
<span class="nc" id="L203">			throw new UnsupportedOperationException(&quot;Parameter of type &quot; + type.getText() + &quot; not implemented.&quot;);</span>
	}

	private String buildParamType(OutputParameterTypeContext type)
	{
<span class="nc bnc" id="L208" title="All 2 branches missed.">		if (type == null)</span>
<span class="nc" id="L209">			return null;</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">		else if (type.scalarType() != null)</span>
		{
<span class="nc" id="L212">			ScalarTypeContext scalarType = type.scalarType();</span>
<span class="nc" id="L213">			ParserRuleContext scalarTypeName = coalesce(scalarType.basicScalarType(), scalarType.valueDomainName());</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">			if (scalarType.scalarTypeConstraint() != null)</span>
<span class="nc" id="L215">				throw new UnsupportedOperationException(&quot;Domain constraint not implemented.&quot;);</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">			if (scalarType.NULL_CONSTANT() != null)</span>
<span class="nc" id="L217">				throw new UnsupportedOperationException(&quot;NULL/NOT NULL constraint not implemented.&quot;);</span>
<span class="nc" id="L218">			return scalarTypeName.getText();</span>
		}
		else
<span class="nc" id="L221">			throw new UnsupportedOperationException(&quot;Parameter of type &quot; + type.getText() + &quot; not implemented.&quot;);</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>OpsFactory.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">vtl-coverage</a> &gt; <a href="../index.html" class="el_bundle">vtl-engine</a> &gt; <a href="index.source.html" class="el_package">it.bancaditalia.oss.vtl.impl.engine.mapping</a> &gt; <span class="el_source">OpsFactory.java</span></div><h1>OpsFactory.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright 2020, Bank Of Italy
 *
 * Licensed under the EUPL, Version 1.2 (the &quot;License&quot;);
 * You may not use this work except in compliance with the
 * License.
 * You may obtain a copy of the License at:
 *
 * https://joinup.ec.europa.eu/sites/default/files/custom-page/attachment/2020-03/EUPL-1.2%20EN.txt
 *
 * Unless required by applicable law or agreed to in
 * writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; basis,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied.
 *
 * See the License for the specific language governing
 * permissions and limitations under the License.
 *******************************************************************************/
package it.bancaditalia.oss.vtl.impl.engine.mapping;

import static it.bancaditalia.oss.vtl.impl.types.domain.Domains.UNKNOWNDS;
import static java.util.stream.Collectors.joining;
import static java.util.stream.Collectors.toList;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Deque;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.stream.IntStream;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.transform.stream.StreamSource;

import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.RuleContext;
import org.antlr.v4.runtime.Token;
import org.antlr.v4.runtime.misc.Interval;
import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.tree.TerminalNode;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import it.bancaditalia.oss.vtl.exceptions.VTLNestedException;
import it.bancaditalia.oss.vtl.grammar.Vtl;
import it.bancaditalia.oss.vtl.grammar.VtlTokens;
import it.bancaditalia.oss.vtl.impl.engine.exceptions.VTLUnmappedContextException;
import it.bancaditalia.oss.vtl.impl.engine.exceptions.VTLUnmappedTokenException;
import it.bancaditalia.oss.vtl.impl.engine.mapping.xml.Check;
import it.bancaditalia.oss.vtl.impl.engine.mapping.xml.Context;
import it.bancaditalia.oss.vtl.impl.engine.mapping.xml.Contextcheck;
import it.bancaditalia.oss.vtl.impl.engine.mapping.xml.Customparam;
import it.bancaditalia.oss.vtl.impl.engine.mapping.xml.Exprparam;
import it.bancaditalia.oss.vtl.impl.engine.mapping.xml.Listparam;
import it.bancaditalia.oss.vtl.impl.engine.mapping.xml.Mapparam;
import it.bancaditalia.oss.vtl.impl.engine.mapping.xml.Mapping;
import it.bancaditalia.oss.vtl.impl.engine.mapping.xml.Nestedparam;
import it.bancaditalia.oss.vtl.impl.engine.mapping.xml.Nonnullparam;
import it.bancaditalia.oss.vtl.impl.engine.mapping.xml.Nullparam;
import it.bancaditalia.oss.vtl.impl.engine.mapping.xml.ObjectFactory;
import it.bancaditalia.oss.vtl.impl.engine.mapping.xml.Param;
import it.bancaditalia.oss.vtl.impl.engine.mapping.xml.Parserconfig;
import it.bancaditalia.oss.vtl.impl.engine.mapping.xml.Roleparam;
import it.bancaditalia.oss.vtl.impl.engine.mapping.xml.Stringparam;
import it.bancaditalia.oss.vtl.impl.engine.mapping.xml.Tokenmapping;
import it.bancaditalia.oss.vtl.impl.engine.mapping.xml.Tokenscheck;
import it.bancaditalia.oss.vtl.impl.engine.mapping.xml.Tokenset;
import it.bancaditalia.oss.vtl.impl.engine.mapping.xml.Tokensetparam;
import it.bancaditalia.oss.vtl.impl.engine.mapping.xml.Valueparam;
import it.bancaditalia.oss.vtl.impl.types.data.BooleanValue;
import it.bancaditalia.oss.vtl.impl.types.data.DoubleValue;
import it.bancaditalia.oss.vtl.impl.types.data.IntegerValue;
import it.bancaditalia.oss.vtl.impl.types.data.NullValue;
import it.bancaditalia.oss.vtl.impl.types.data.StringValue;
import it.bancaditalia.oss.vtl.model.data.ComponentRole;
import it.bancaditalia.oss.vtl.model.data.ComponentRole.Attribute;
import it.bancaditalia.oss.vtl.model.data.ComponentRole.Identifier;
import it.bancaditalia.oss.vtl.model.data.ComponentRole.Measure;
import it.bancaditalia.oss.vtl.model.data.ComponentRole.ViralAttribute;
import it.bancaditalia.oss.vtl.model.data.ScalarValue;
import it.bancaditalia.oss.vtl.model.transform.Transformation;
import it.bancaditalia.oss.vtl.util.TriFunction;

public class OpsFactory
{
	private static class VTLParsingException extends RuntimeException
	{
		private static final long serialVersionUID = 1L;

		public VTLParsingException(ParserRuleContext ctx, Throwable t)
		{
<span class="nc" id="L108">			super(&quot;In context &quot; + ctx.getClass().getSimpleName() + &quot; on expression: &quot;</span>
<span class="nc" id="L109">					+ ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex())), t);</span>
<span class="nc" id="L110">		}</span>
	}

<span class="nc" id="L113">	private static final Logger LOGGER = LoggerFactory.getLogger(OpsFactory.class);</span>
<span class="nc" id="L114">	private static final String MAPPING_FILENAME = OpsFactory.class.getName().replaceAll(&quot;\\.&quot;, &quot;/&quot;) + &quot;.xml&quot;;</span>

<span class="nc" id="L116">	private final Map&lt;Class&lt;? extends Nonnullparam&gt;, TriFunction&lt;ParserRuleContext, Integer, Nonnullparam, Object&gt;&gt; paramMappers = new HashMap&lt;&gt;();</span>
<span class="nc" id="L117">	private final Map&lt;Class&lt;? extends ParserRuleContext&gt;, List&lt;Mapping&gt;&gt; mappings = new HashMap&lt;&gt;();</span>
<span class="nc" id="L118">	private final Map&lt;String, Tokenset&gt; tokensets = new HashMap&lt;&gt;();</span>
<span class="nc" id="L119">	private final Set&lt;Class&lt;? extends ParserRuleContext&gt;&gt; recursivecontexts = new HashSet&lt;&gt;();</span>

	public OpsFactory() throws JAXBException, ClassNotFoundException, IOException
<span class="nc" id="L122">	{</span>
<span class="nc" id="L123">		paramMappers.put(Tokensetparam.class, (b, c, d) -&gt; parseMapParam(b, c, (Tokensetparam) d));</span>
<span class="nc" id="L124">		paramMappers.put(Valueparam.class, (b, c, d) -&gt; parseValueParam(b, c, (Valueparam) d));</span>
<span class="nc" id="L125">		paramMappers.put(Roleparam.class, (b, c, d) -&gt; parseRoleParam(b, c, (Roleparam) d));</span>
<span class="nc" id="L126">		paramMappers.put(Stringparam.class, (b, c, d) -&gt; parseStringParam(b, c, (Stringparam) d));</span>
<span class="nc" id="L127">		paramMappers.put(Listparam.class, (b, c, d) -&gt; parseListParam(b, c, (Listparam) d));</span>
<span class="nc" id="L128">		paramMappers.put(Mapparam.class, (b, c, d) -&gt; parseMapParam(b, c, (Mapparam) d));</span>
<span class="nc" id="L129">		paramMappers.put(Nestedparam.class, (b, c, d) -&gt; parseNestedParam(b, c, (Nestedparam) d));</span>
<span class="nc" id="L130">		paramMappers.put(Customparam.class, (b, c, d) -&gt; parseCustomParam(b, c, (Customparam) d));</span>
<span class="nc" id="L131">		paramMappers.put(Exprparam.class, (b, c, d) -&gt; parseExprParam(b, c, (Exprparam) d));</span>

<span class="nc" id="L133">		JAXBContext jc = JAXBContext.newInstance(ObjectFactory.class);</span>
<span class="nc" id="L134">		Enumeration&lt;URL&gt; files = this.getClass().getClassLoader().getResources(MAPPING_FILENAME);</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">		if (!files.hasMoreElements())</span>
		{
<span class="nc" id="L137">			IllegalStateException ex = new IllegalStateException(&quot;Cannot find VTL mapping file, &quot; + MAPPING_FILENAME);</span>
<span class="nc" id="L138">			LOGGER.error(&quot;Cannot find any mapping files. Forgot to add an implementation to your classpath?&quot;);</span>
<span class="nc" id="L139">			throw ex;</span>
		}

<span class="nc" id="L142">		boolean first = true;</span>
<span class="nc" id="L143">		URL file = null;</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">		while (files.hasMoreElements())</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">			if (first)</span>
			{
<span class="nc" id="L147">				file = files.nextElement();</span>
<span class="nc" id="L148">				first = false;</span>
<span class="nc" id="L149">				LOGGER.info(&quot;Using VTL configuration file: {}&quot;, file);</span>
			}
			else
			{
<span class="nc" id="L153">				files.nextElement();</span>
<span class="nc" id="L154">				LOGGER.warn(&quot;Ignored additional VTL configuration file: {}&quot;, file);</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">				if (!files.hasMoreElements())</span>
<span class="nc" id="L156">					LOGGER.warn(&quot;Multiple configurations detected: you may have multiple implementations in your classpath!&quot;);</span>
			}
		
<span class="nc bnc" id="L159" title="All 2 branches missed.">		if (file == null)</span>
<span class="nc" id="L160">			throw new FileNotFoundException(&quot;VTL mapping configuration file not found in classpath.&quot;);</span>

<span class="nc" id="L162">		StreamSource xmlConfig = new StreamSource(file.openStream());</span>
<span class="nc" id="L163">		Parserconfig config = jc.createUnmarshaller().unmarshal(xmlConfig, Parserconfig.class).getValue();</span>

<span class="nc" id="L165">		LOGGER.debug(&quot;Loading mappings&quot;);</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">		for (Mapping mapping : config.getMapping())</span>
		{
<span class="nc" id="L168">			Class&lt;? extends ParserRuleContext&gt; from = Class.forName(Vtl.class.getName() + &quot;$&quot; + mapping.getFrom()).asSubclass(ParserRuleContext.class);</span>
<span class="nc" id="L169">			mappings.putIfAbsent(from, new ArrayList&lt;&gt;());</span>
<span class="nc" id="L170">			mappings.get(from).add(mapping);</span>
<span class="nc" id="L171">			LOGGER.trace(&quot;Loaded mapping {} for context '{}'.&quot;, from, mapping.getTo());</span>
<span class="nc" id="L172">		}</span>

<span class="nc" id="L174">		LOGGER.debug(&quot;Loading tokensets&quot;);</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">		for (Tokenset tokenset : config.getTokenset())</span>
		{
<span class="nc" id="L177">			tokensets.put(tokenset.getName(), tokenset);</span>
<span class="nc" id="L178">			LOGGER.trace(&quot;Loaded tokenset {} for tokenset '{}'.&quot;, tokenset.getClazz(), tokenset.getName());</span>
<span class="nc" id="L179">		}</span>

<span class="nc" id="L181">		LOGGER.debug(&quot;Loading recursive context&quot;);</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">		for (Context context : config.getRecursivecontexts().getContext())</span>
<span class="nc" id="L183">			recursivecontexts.add(Class.forName(Vtl.class.getName() + &quot;$&quot; + context.getName()).asSubclass(ParserRuleContext.class));</span>
<span class="nc" id="L184">	}</span>

	public Transformation buildExpr(ParserRuleContext ctx)
	{
<span class="nc" id="L188">		String ctxText = ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));</span>
<span class="nc" id="L189">		LOGGER.debug(&quot;Parsing new context {} containing '{}'.&quot;, ctx.getClass().getSimpleName(), ctxText);</span>
<span class="nc" id="L190">		return buildExpr(ctx, 0);</span>
	}

	private Transformation buildExpr(ParserRuleContext ctx, int level)
	{
<span class="nc" id="L195">		String tabs = new String(new char[level]).replace(&quot;\0&quot;, &quot;    &quot;);</span>
<span class="nc" id="L196">		Class&lt;? extends ParserRuleContext&gt; ctxClass = ctx.getClass();</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">		if (recursivecontexts.contains(ctxClass))</span>
		{
<span class="nc" id="L199">			LOGGER.trace(&quot;|{}&gt;&gt; Resolving recursive context {}&quot;, tabs, ctxClass.getSimpleName());</span>
<span class="nc" id="L200">			Transformation result = buildExpr(ctx.getRuleContext(ParserRuleContext.class, 0), level + 1);</span>
<span class="nc" id="L201">			LOGGER.trace(&quot;|{}&lt;&lt; Recursive context {} yield {}&quot;, tabs, ctxClass.getSimpleName(), result.getClass().getSimpleName());</span>
<span class="nc" id="L202">			return result;</span>
		}

		// Find all mappings that map a context that is the same class or a subclass of given context
<span class="nc" id="L206">		List&lt;Mapping&gt; available = mappings.keySet().stream()</span>
<span class="nc" id="L207">				.filter(c -&gt; c.isAssignableFrom(ctxClass))</span>
<span class="nc" id="L208">				.flatMap(c -&gt; mappings.get(c).stream())</span>
<span class="nc" id="L209">				.collect(toList());</span>

<span class="nc" id="L211">		LOGGER.trace(&quot;|{}|| Found {} mappings for {}&quot;, tabs, available.size(), ctx.getClass().getSimpleName());</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">		for (Mapping mapping : available)</span>
			try
			{
<span class="nc" id="L215">				boolean found = checkMapping(mapping.getTokensOrContextOrNested(), ctx);</span>
<span class="nc" id="L216">				Class&lt;?&gt; target = Class.forName(mapping.getTo());</span>

<span class="nc bnc" id="L218" title="All 2 branches missed.">				if (found)</span>
				{
<span class="nc" id="L220">					String paramsClasses = mapping.getParams().getNullparamOrStringparamOrExprparam().stream()</span>
<span class="nc" id="L221">							.map(Object::getClass)</span>
<span class="nc" id="L222">							.map(Class::getSimpleName)</span>
<span class="nc" id="L223">							.collect(joining(&quot;, &quot;, &quot;{&quot;, &quot;}&quot;));</span>

<span class="nc" id="L225">					LOGGER.trace(&quot;|{}&gt;&gt; Resolving {} for {}&quot;, tabs, paramsClasses, target.getSimpleName());</span>
<span class="nc" id="L226">					List&lt;Object&gt; args = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">					for (Param param : mapping.getParams().getNullparamOrStringparamOrExprparam())</span>
					{
<span class="nc" id="L229">						Object oneOrMoreParam = createParam(ctx, param, level + 1);</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">						if (param instanceof Nestedparam)</span>
<span class="nc" id="L231">							args.addAll((Collection&lt;?&gt;) oneOrMoreParam);</span>
						else
<span class="nc" id="L233">							args.add(oneOrMoreParam);</span>
<span class="nc" id="L234">					}</span>

<span class="nc" id="L236">					Constructor&lt;?&gt; constructor = findConstructor(target, args, level);</span>
<span class="nc" id="L237">					LOGGER.trace(&quot;|{}&lt;&lt; Invoking constructor for {} with {}&quot;, tabs, target.getSimpleName(), args);</span>

<span class="nc" id="L239">					return (Transformation) constructor.newInstance(args.toArray());</span>
				}
			}
<span class="nc" id="L242">			catch (Exception e)</span>
			{
<span class="nc" id="L244">				throw new VTLNestedException(</span>
<span class="nc" id="L245">						&quot;In expression &quot; + ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex())), e);</span>
<span class="nc" id="L246">			}</span>

<span class="nc" id="L248">		throw new VTLUnmappedContextException(ctx);</span>
	}

	private Constructor&lt;?&gt; findConstructor(Class&lt;?&gt; target, List&lt;Object&gt; args, int level)
	{
<span class="nc" id="L253">		String tabs = new String(new char[level]).replace(&quot;\0&quot;, &quot;    &quot;);</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">		if (!Transformation.class.isAssignableFrom(target))</span>
<span class="nc" id="L255">			throw new ClassCastException(target + &quot; does not implement &quot; + Transformation.class);</span>

<span class="nc" id="L257">		Constructor&lt;?&gt;[] constructors = target.asSubclass(Transformation.class).getConstructors();</span>

<span class="nc bnc" id="L259" title="All 2 branches missed.">		if (constructors.length &lt; 1)</span>
<span class="nc" id="L260">			throw new IllegalStateException(&quot;Expected at least one public constructor but found none for &quot; + target.getSimpleName());</span>

<span class="nc bnc" id="L262" title="All 2 branches missed.">		List&lt;Class&lt;?&gt;&gt; argsClasses = args.stream().map(p -&gt; p != null ? p.getClass() : null).collect(toList());</span>

<span class="nc bnc" id="L264" title="All 2 branches missed.">		for (Constructor&lt;?&gt; constr : constructors)</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">			if (constr.getParameterCount() == args.size())</span>
			{
<span class="nc" id="L267">				Class&lt;?&gt;[] parameterTypes = constr.getParameterTypes();</span>
<span class="nc" id="L268">				boolean isValid = true;</span>
<span class="nc bnc" id="L269" title="All 4 branches missed.">				for (int i = 0; isValid &amp;&amp; i &lt; args.size(); i++)</span>
<span class="nc bnc" id="L270" title="All 4 branches missed.">					if (argsClasses.get(i) != null &amp;&amp; !parameterTypes[i].isAssignableFrom(argsClasses.get(i)))</span>
<span class="nc" id="L271">						isValid = false;</span>

<span class="nc bnc" id="L273" title="All 2 branches missed.">				if (isValid)</span>
				{
<span class="nc" id="L275">					String argsClsStr = argsClasses.stream()</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">							.map(c -&gt; c != null ? c.getSimpleName() : &quot;&quot;)</span>
<span class="nc" id="L277">							.collect(joining(&quot;, &quot;, &quot;{&quot;, &quot;}&quot;));</span>

<span class="nc" id="L279">					LOGGER.trace(&quot;|{}|| Found constructor for {} with {}&quot;, tabs, target.getSimpleName(), argsClsStr);</span>
<span class="nc" id="L280">					return constr;</span>
				}
			}

<span class="nc bnc" id="L284" title="All 2 branches missed.">		String text = argsClasses.stream().map(c -&gt; c != null ? c.getSimpleName() : null).collect(joining(&quot;, &quot;, &quot;[&quot;, &quot;]&quot;));</span>
<span class="nc" id="L285">		throw new IllegalStateException(&quot;Could not find a suitable public constructor for &quot; + target.getSimpleName() + &quot; with &quot; + text);</span>
	}

	private boolean checkMapping(Check check, ParserRuleContext ctx)
	{
<span class="nc" id="L290">		Class&lt;? extends ParserRuleContext&gt; ctxClass = ctx.getClass();</span>

		try
		{
<span class="nc bnc" id="L294" title="All 2 branches missed.">			boolean checkIsValid = check == null;</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">			if (!checkIsValid)</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">				if (check instanceof Tokenscheck)</span>
				{
<span class="nc" id="L298">					Tokenscheck tokens = (Tokenscheck) check;</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">					for (String value : tokens.getValue())</span>
					{
<span class="nc" id="L301">						LOGGER.trace(&quot;Searching for token {}&quot;, value);</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">						if (!checkIsValid)</span>
<span class="nc" id="L303">							checkIsValid = searchToken(ctx, tokens, value);</span>
<span class="nc" id="L304">					}</span>
<span class="nc" id="L305">				}</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">				else if (check instanceof Contextcheck)</span>
				{
<span class="nc" id="L308">					Contextcheck context = (Contextcheck) check;</span>
<span class="nc" id="L309">					Class&lt;? extends ParserRuleContext&gt; target = Class.forName(Vtl.class.getName() + &quot;$&quot; + context.getContext())</span>
<span class="nc" id="L310">							.asSubclass(ParserRuleContext.class);</span>
<span class="nc" id="L311">					Class&lt;? extends Object&gt; childruleclass = ctxClass.getField(context.getName()).get(ctx).getClass();</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">					if (target == childruleclass)</span>
<span class="nc" id="L313">						checkIsValid = true;</span>
<span class="nc" id="L314">				}</span>
				else
<span class="nc" id="L316">					throw new UnsupportedOperationException(&quot;Check of class &quot; + check.getClass().getSimpleName() + &quot; not implemented.&quot;);</span>

<span class="nc" id="L318">			return checkIsValid;</span>
		}
<span class="nc" id="L320">		catch (ClassNotFoundException | IllegalAccessException | NoSuchFieldException e)</span>
		{
<span class="nc" id="L322">			throw new VTLParsingException(ctx, e);</span>
		}
	}

	private boolean searchToken(ParserRuleContext ctx, Tokenscheck tokens, String value)
	{
		try
		{
<span class="nc" id="L330">			boolean found = false;</span>
<span class="nc" id="L331">			Class&lt;? extends ParserRuleContext&gt; ctxClass = ctx.getClass();</span>
			
			try
			{
<span class="nc bnc" id="L335" title="All 2 branches missed.">				if (((Token) ctxClass.getField(tokens.getName()).get(ctx)).getType() == VtlTokens.class.getField(value).getInt(null))</span>
				{
<span class="nc" id="L337">					LOGGER.trace(&quot;Token {} found.&quot;, value);</span>
<span class="nc" id="L338">					found = true;</span>
				}
			}
<span class="nc" id="L341">			catch (NoSuchFieldException e)</span>
			{
<span class="nc" id="L343">				ParseTree rule = (ParseTree) ctxClass.getMethod(tokens.getName()).invoke(ctx);</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">				if (rule != null)</span>
				{
<span class="nc" id="L346">					TerminalNode leaf = (TerminalNode) rule.getClass().getMethod(value).invoke(rule);</span>
<span class="nc bnc" id="L347" title="All 4 branches missed.">					if (leaf != null &amp;&amp; ((Token) leaf.getPayload()).getType() == VtlTokens.class.getField(value).getInt(null))</span>
					{
<span class="nc" id="L349">						LOGGER.trace(&quot;Token {} found.&quot;, value);</span>
<span class="nc" id="L350">						found = true;</span>
					}
				}
<span class="nc" id="L353">			}</span>
			
<span class="nc" id="L355">			return found;</span>
		}
<span class="nc" id="L357">		catch (NoSuchMethodException | NoSuchFieldException | IllegalAccessException | InvocationTargetException e)</span>
		{
<span class="nc" id="L359">			throw new VTLParsingException(ctx, e);</span>
		}
	}

	private Object createParam(ParserRuleContext ctx, Param maybeNullParam, int level)
	{
<span class="nc" id="L365">		String tabs = new String(new char[level]).replace(&quot;\0&quot;, &quot;    &quot;);</span>
		
<span class="nc" id="L367">		Objects.requireNonNull(ctx, &quot;Parsing context is null&quot;);</span>
		
<span class="nc bnc" id="L369" title="All 2 branches missed.">		if (maybeNullParam instanceof Nullparam)</span>
		{
<span class="nc" id="L371">			LOGGER.trace(&quot;|{}&gt;&gt; {}: Null&quot;, tabs, ctx.getClass().getSimpleName());</span>
<span class="nc" id="L372">			LOGGER.trace(&quot;|{}&lt;&lt; {}: Null&quot;, tabs, ctx.getClass().getSimpleName());</span>
<span class="nc" id="L373">			return null;</span>
		}
		else
		{
<span class="nc" id="L377">			Nonnullparam param = (Nonnullparam) maybeNullParam;</span>
<span class="nc" id="L378">			Class&lt;? extends Param&gt; paramClass = param.getClass();</span>
			Object result;
<span class="nc bnc" id="L380" title="All 2 branches missed.">			if (param.getName() != null)</span>
<span class="nc" id="L381">				LOGGER.trace(&quot;|{}&gt;&gt; {}: {} from subrule '{}'&quot;, tabs, ctx.getClass().getSimpleName(), paramClass.getSimpleName(), param.getName());</span>
			else
<span class="nc" id="L383">				LOGGER.trace(&quot;|{}&gt;&gt; {}: {} from same context&quot;, tabs, ctx.getClass().getSimpleName(), paramClass.getSimpleName());</span>

<span class="nc" id="L385">			TriFunction&lt;ParserRuleContext, Integer, Nonnullparam, Object&gt; contextParser = paramMappers.get(param.getClass());</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">			if (contextParser == null)</span>
<span class="nc" id="L387">				throw new IllegalStateException(&quot;Not implemented: &quot; + param.getClass().getName());</span>
				
<span class="nc" id="L389">			result = contextParser.apply(ctx, level, param);</span>

<span class="nc bnc" id="L391" title="All 2 branches missed.">			if (param.getName() != null)</span>
<span class="nc" id="L392">				LOGGER.trace(&quot;|{}&lt;&lt; {}: {} from rule '{}' yield {}&quot;, tabs, ctx.getClass().getSimpleName(), paramClass.getSimpleName(), param.getName(), result);</span>
			else
<span class="nc" id="L394">				LOGGER.trace(&quot;|{}&lt;&lt; {}: {} from same context yield {}&quot;, tabs, ctx.getClass().getSimpleName(), paramClass.getSimpleName(), result);</span>

<span class="nc" id="L396">			return result;</span>
		}
	}

	private Transformation parseExprParam(ParserRuleContext ctx, int level, Exprparam param)
	{
		Transformation result;
<span class="nc" id="L403">		ParserRuleContext subexpr = getFieldOrMethod(param, ctx, ParserRuleContext.class, level);</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">		result = subexpr == null ? null : buildExpr(subexpr, level + 1);</span>
<span class="nc" id="L405">		return result;</span>
	}

	private Object parseCustomParam(ParserRuleContext ctx, int level, Customparam customParam)
	{
		try
		{
			Object result;
<span class="nc" id="L413">			List&lt;Nonnullparam&gt; innerParams = customParam.getStringparamOrExprparamOrValueparam();</span>
<span class="nc" id="L414">			ParserRuleContext customCtx = getFieldOrMethod(customParam, ctx, ParserRuleContext.class, level);</span>
<span class="nc" id="L415">			Class&lt;?&gt; customClass = Class.forName(customParam.getClazz());</span>
<span class="nc" id="L416">			List&lt;Object&gt; resultList = new ArrayList&lt;&gt;(innerParams.size());</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">			for (Nonnullparam child : innerParams)</span>
<span class="nc" id="L418">				resultList.add(createParam(customCtx, child, level + 1));</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">			if (customParam.getMethod() != null)</span>
<span class="nc" id="L420">				result = Arrays.stream(customClass.getMethods())</span>
<span class="nc" id="L421">						.filter(m -&gt; m.getName().equals(customParam.getMethod()))</span>
<span class="nc" id="L422">						.findAny()</span>
<span class="nc" id="L423">						.orElseThrow(() -&gt; new NoSuchMethodException(customParam.getMethod()))</span>
<span class="nc" id="L424">						.invoke(null, resultList.toArray());</span>
			else
<span class="nc" id="L426">				result = customClass.getConstructors()[0]</span>
<span class="nc" id="L427">						.newInstance(resultList.toArray());</span>
<span class="nc" id="L428">			return result;</span>
		}
<span class="nc" id="L430">		catch (ClassNotFoundException | IllegalAccessException | InvocationTargetException | NoSuchMethodException | InstantiationException e)</span>
		{
<span class="nc" id="L432">			throw new VTLParsingException(ctx, e);</span>
		}
	}

	private Object parseNestedParam(ParserRuleContext ctx, int level, Nestedparam nestedParam)
	{
		Object result;
<span class="nc" id="L439">		ParserRuleContext nestedCtx = getFieldOrMethod(nestedParam, ctx, ParserRuleContext.class, level);</span>
<span class="nc" id="L440">		List&lt;Nonnullparam&gt; innerParams = nestedParam.getStringparamOrExprparamOrValueparam();</span>
<span class="nc" id="L441">		List&lt;Object&gt; resultList = new ArrayList&lt;&gt;(innerParams.size());</span>
<span class="nc bnc" id="L442" title="All 2 branches missed.">		for (Nonnullparam child : innerParams)</span>
<span class="nc bnc" id="L443" title="All 2 branches missed.">			resultList.add(nestedCtx == null ? null : createParam(nestedCtx, child, level + 1));</span>
<span class="nc" id="L444">		result = resultList;</span>
<span class="nc" id="L445">		return result;</span>
	}

	private Map&lt;?, ?&gt; parseMapParam(ParserRuleContext ctx, int level, Mapparam mapparam)
	{
		Map&lt;?, ?&gt; result;
<span class="nc" id="L451">		Map&lt;Object, Object&gt; resultMap = new HashMap&lt;&gt;();</span>
		@SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L453">		List&lt;? extends ParserRuleContext&gt; entries = getFieldOrMethod(mapparam, ctx, List.class, level);</span>
<span class="nc" id="L454">		Nonnullparam keyParam = mapparam.getStringparamOrExprparamOrValueparam().get(0);</span>
<span class="nc" id="L455">		Nonnullparam valueParam = mapparam.getStringparamOrExprparamOrValueparam().get(1);</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">		for (ParserRuleContext entry : entries)</span>
		{
<span class="nc" id="L458">			Object key = createParam(entry, keyParam, level + 1);</span>
<span class="nc" id="L459">			Object value = createParam(entry, valueParam, level + 1);</span>
<span class="nc" id="L460">			resultMap.put(key, value);</span>
<span class="nc" id="L461">		}</span>
<span class="nc" id="L462">		result = resultMap;</span>
<span class="nc" id="L463">		return result;</span>
	}

	private List&lt;?&gt; parseListParam(ParserRuleContext ctx, int level, Listparam listParam)
	{
		List&lt;?&gt; result;
<span class="nc" id="L469">		Nonnullparam insideParam = listParam.getStringparamOrExprparamOrValueparam();</span>
		@SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L471">		Collection&lt;? extends ParserRuleContext&gt; inside = getFieldOrMethod(listParam, ctx, Collection.class, level);</span>
<span class="nc" id="L472">		List&lt;Object&gt; resultList = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">		for (ParserRuleContext child : inside)</span>
<span class="nc" id="L474">			resultList.add(createParam(child, insideParam, level + 1));</span>
<span class="nc" id="L475">		result = resultList;</span>
<span class="nc" id="L476">		return result;</span>
	}

	private String parseStringParam(ParserRuleContext ctx, int level, Stringparam stringparam)
	{
		String result;
<span class="nc" id="L482">		Object value = getFieldOrMethod(stringparam, ctx, Object.class, level);</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">		if (value instanceof Token)</span>
<span class="nc" id="L484">			result = ((Token) value).getText();</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">		else if (value instanceof ParseTree)</span>
<span class="nc" id="L486">			result = ((ParseTree) value).getText();</span>
		else
<span class="nc" id="L488">			result = null;</span>
<span class="nc" id="L489">		return result;</span>
	}

	private Class&lt;? extends ComponentRole&gt; parseRoleParam(ParserRuleContext ctx, int level, Roleparam param)
	{
		// lookup actual token
<span class="nc" id="L495">		ParseTree roleCtx = getFieldOrMethod(param, ctx, ParseTree.class, level);</span>
<span class="nc" id="L496">		Deque&lt;ParseTree&gt; stack = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L497">		List&lt;Token&gt; resultList = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L498">		stack.push(roleCtx);</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">		while (!stack.isEmpty())</span>
		{
<span class="nc" id="L501">			ParseTree current = stack.pop();</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">			if (current instanceof TerminalNode)</span>
<span class="nc" id="L503">				resultList.add((Token) current.getPayload());</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">			else if (current instanceof RuleContext)</span>
<span class="nc" id="L505">				IntStream.range(0, current.getChildCount())</span>
<span class="nc" id="L506">					.forEachOrdered(i -&gt; stack.push(current.getChild(i)));</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">			else if (current != null)</span>
<span class="nc" id="L508">				throw new IllegalStateException(&quot;Unexpected ParseTree of &quot; + current.getClass());</span>
<span class="nc" id="L509">		}</span>

<span class="nc bnc" id="L511" title="All 2 branches missed.">		Optional&lt;Token&gt; firstToken = Optional.ofNullable(resultList.isEmpty() ? null : resultList.get(0));</span>
<span class="nc bnc" id="L512" title="All 2 branches missed.">		Optional&lt;Token&gt; secondToken = Optional.ofNullable(resultList.size() &lt; 2 ? null : resultList.get(1));</span>
		
<span class="nc bnc" id="L514" title="All 2 branches missed.">		if (!firstToken.isPresent())</span>
<span class="nc" id="L515">			return null;</span>
<span class="nc bnc" id="L516" title="All 2 branches missed.">		else if (!secondToken.isPresent())</span>
<span class="nc bnc" id="L517" title="All 4 branches missed.">			switch (firstToken.get().getType())</span>
			{
<span class="nc" id="L519">				case Vtl.MEASURE: return Measure.class;</span>
<span class="nc" id="L520">				case Vtl.DIMENSION: return Identifier.class;</span>
<span class="nc" id="L521">				case Vtl.ATTRIBUTE: return Attribute.class;</span>
				default: 
<span class="nc" id="L523">					throw new IllegalStateException(&quot;Unrecognized role token &quot; + Vtl.VOCABULARY.getSymbolicName(firstToken.get().getType()) </span>
<span class="nc" id="L524">							+ &quot; containing &quot; + firstToken.get().getText());</span>
			}
<span class="nc bnc" id="L526" title="All 4 branches missed.">		else if (firstToken.get().getType() == Vtl.VIRAL &amp;&amp; secondToken.get().getType() == Vtl.ATTRIBUTE)</span>
<span class="nc" id="L527">			return ViralAttribute.class;</span>
		else
		{
<span class="nc" id="L530">			throw new IllegalStateException(&quot;Unrecognized role token &quot; + Vtl.VOCABULARY.getSymbolicName(firstToken.get().getType()) </span>
<span class="nc" id="L531">					+ &quot; containing &quot; + firstToken.get().getText());</span>
		}
	}

	private ScalarValue&lt;?, ?, ?&gt; parseValueParam(ParserRuleContext ctx, int level, Valueparam param)
	{
		// lookup actual token
<span class="nc" id="L538">		Token token = (Token) (getFieldOrMethod(param, ctx, ParserRuleContext.class, level)).getChild(TerminalNode.class, 0).getPayload();</span>
<span class="nc" id="L539">		int tokenType = token.getType();</span>
<span class="nc bnc" id="L540" title="All 6 branches missed.">		switch (tokenType)</span>
		{
<span class="nc" id="L542">			case Vtl.INTEGER_CONSTANT: return new IntegerValue(Long.parseLong(token.getText()));</span>
<span class="nc" id="L543">			case Vtl.NUMBER_CONSTANT: return new DoubleValue(Double.parseDouble(token.getText()));</span>
<span class="nc" id="L544">			case Vtl.BOOLEAN_CONSTANT: return BooleanValue.of(Boolean.parseBoolean(token.getText()));</span>
<span class="nc" id="L545">			case Vtl.STRING_CONSTANT: return new StringValue(token.getText());</span>
<span class="nc" id="L546">			case Vtl.NULL_CONSTANT: return NullValue.instance(UNKNOWNDS);</span>
<span class="nc" id="L547">			default: throw new VTLUnmappedTokenException(token.toString(), null);</span>
		}
	}

	private Enum&lt;?&gt; parseMapParam(ParserRuleContext ctx, int level, Tokensetparam tokensetParam)
	{
		try
		{
			Enum&lt;?&gt; result;
			// get the tokenset
<span class="nc" id="L557">			Tokenset tokenset = Objects.requireNonNull(tokensets.get(tokensetParam.getTokenset()),</span>
<span class="nc" id="L558">					&quot;Tokenset &quot; + tokensetParam.getTokenset() + &quot; not found in mapping&quot;);</span>
			// lookup actual token
<span class="nc" id="L560">			Object rule = getFieldOrMethod(tokensetParam, ctx, Object.class, level);</span>
<span class="nc bnc" id="L561" title="All 2 branches missed.">			if (rule == null)</span>
<span class="nc" id="L562">				result = null;</span>
			else
			{
<span class="nc bnc" id="L565" title="All 2 branches missed.">				if (rule instanceof ParserRuleContext)</span>
<span class="nc" id="L566">					rule = ((ParserRuleContext) rule).getChild(TerminalNode.class, 0);</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">				if (rule != null)</span>
				{
<span class="nc bnc" id="L569" title="All 2 branches missed.">					Token token = rule instanceof Token ? (Token) rule : (Token) ((TerminalNode) rule).getPayload();</span>
<span class="nc" id="L570">					String sourceToken = VtlTokens.VOCABULARY.getSymbolicName(token.getType());</span>
					// find corresponding enum value
<span class="nc" id="L572">					Optional&lt;Tokenmapping&gt; matchingToken = tokenset.getTokenmapping().stream().filter(t -&gt; t.getName().equals(sourceToken)).findAny();</span>
<span class="nc bnc" id="L573" title="All 2 branches missed.">					if (!matchingToken.isPresent())</span>
<span class="nc" id="L574">						throw new VTLUnmappedTokenException(sourceToken, tokenset);</span>
					// get the enum value
<span class="nc" id="L576">					Enum&lt;?&gt; enumValue = Enum.valueOf(Class.forName(tokenset.getClazz()).asSubclass(Enum.class), matchingToken.get().getValue());</span>
<span class="nc" id="L577">					result = enumValue;</span>
<span class="nc" id="L578">				}</span>
				else
<span class="nc" id="L580">					result = null;</span>
			}
<span class="nc" id="L582">			return result;</span>
		}
<span class="nc" id="L584">		catch (ClassNotFoundException e)</span>
		{
<span class="nc" id="L586">			throw new VTLParsingException(ctx, e);</span>
		}
	}

	private &lt;T&gt; T getFieldOrMethod(Nonnullparam param, RuleContext entry, Class&lt;T&gt; resultClass, int level)
	{
		try
		{
<span class="nc" id="L594">			String tabs = &quot;&quot;;</span>
<span class="nc bnc" id="L595" title="All 2 branches missed.">			for (int i = 0; i &lt;= level; i++)</span>
<span class="nc" id="L596">				tabs += &quot;    &quot;;</span>
<span class="nc" id="L597">			Class&lt;? extends RuleContext&gt; ctxClass = entry.getClass();</span>
<span class="nc" id="L598">			Object result = entry;</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">			if (param.getName() != null)</span>
			{
<span class="nc" id="L601">				LOGGER.trace(&quot;|{}&gt;&gt; Looking up subrule '{}' as a {}&quot;, tabs, param.getName(), param.getClass().getSimpleName());</span>
<span class="nc" id="L602">				Optional&lt;Field&gt; field = Arrays.stream(ctxClass.getFields()).filter(f -&gt; f.getName().equals(param.getName())).findFirst();</span>
<span class="nc bnc" id="L603" title="All 2 branches missed.">				if (field.isPresent())</span>
<span class="nc" id="L604">					result = field.get().get(entry);</span>
				else
<span class="nc" id="L606">					result = ctxClass.getMethod(param.getName()).invoke(entry);</span>
<span class="nc" id="L607">			}</span>
			else
<span class="nc" id="L609">				LOGGER.trace(&quot;|{}&gt;&gt; Looking up context {}&quot;, tabs, entry.getClass().getSimpleName());</span>
	
<span class="nc bnc" id="L611" title="All 2 branches missed.">			if (param.getOrdinal() != null)</span>
<span class="nc" id="L612">				result = ((List&lt;?&gt;) result).get(param.getOrdinal());</span>
	
<span class="nc bnc" id="L614" title="All 2 branches missed.">			if (result instanceof ParserRuleContext)</span>
			{
<span class="nc" id="L616">				ParserRuleContext resultCtx = (ParserRuleContext) result;</span>
<span class="nc" id="L617">				String ctxText = resultCtx.start.getInputStream().getText(new Interval(resultCtx.start.getStartIndex(), resultCtx.stop.getStopIndex()));</span>
<span class="nc" id="L618">				LOGGER.trace(&quot;|{}&lt;&lt; Found child context {} with value '{}'&quot;, tabs, result.getClass().getSimpleName(), ctxText);</span>
<span class="nc" id="L619">			}</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">			else if (result instanceof Token)</span>
			{
<span class="nc" id="L622">				Token token = (Token) result;</span>
<span class="nc" id="L623">				String sourceToken = VtlTokens.VOCABULARY.getSymbolicName(token.getType());</span>
<span class="nc" id="L624">				LOGGER.trace(&quot;|{}&lt;&lt; Found token {} with value '{}'&quot;, tabs, sourceToken, token.getText());</span>
<span class="nc" id="L625">			}</span>
<span class="nc bnc" id="L626" title="All 2 branches missed.">			else if (result instanceof TerminalNode)</span>
			{
<span class="nc" id="L628">				Token token = (Token) ((TerminalNode) result).getPayload();</span>
<span class="nc" id="L629">				String sourceToken = VtlTokens.VOCABULARY.getSymbolicName(token.getType());</span>
<span class="nc" id="L630">				LOGGER.trace(&quot;|{}&lt;&lt; Found token {} with value '{}'&quot;, tabs, sourceToken, token.getText());</span>
<span class="nc" id="L631">			}</span>
<span class="nc bnc" id="L632" title="All 2 branches missed.">			else if (result != null)</span>
<span class="nc" id="L633">				LOGGER.trace(&quot;|{}&lt;&lt; Found result {} with value {}&quot;, tabs, result.getClass(), result);</span>
			else
<span class="nc" id="L635">				LOGGER.trace(&quot;|{}&lt;&lt; Found null result&quot;, tabs);</span>
	
<span class="nc" id="L637">			return resultClass.cast(result);</span>
		}
<span class="nc" id="L639">		catch (IllegalArgumentException | IllegalAccessException | InvocationTargetException | NoSuchMethodException | SecurityException e)</span>
		{
<span class="nc" id="L641">			throw new VTLNestedException(&quot;Error parsing expression&quot;, e);</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>
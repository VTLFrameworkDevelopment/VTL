<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>JavaVTLEngine.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">vtl-coverage</a> &gt; <a href="../index.html" class="el_bundle">vtl-engine</a> &gt; <a href="index.source.html" class="el_package">it.bancaditalia.oss.vtl.impl.engine</a> &gt; <span class="el_source">JavaVTLEngine.java</span></div><h1>JavaVTLEngine.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright 2020, Bank Of Italy
 *
 * Licensed under the EUPL, Version 1.2 (the &quot;License&quot;);
 * You may not use this work except in compliance with the
 * License.
 * You may obtain a copy of the License at:
 *
 * https://joinup.ec.europa.eu/sites/default/files/custom-page/attachment/2020-03/EUPL-1.2%20EN.txt
 *
 * Unless required by applicable law or agreed to in
 * writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; basis,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied.
 *
 * See the License for the specific language governing
 * permissions and limitations under the License.
 *******************************************************************************/
package it.bancaditalia.oss.vtl.impl.engine;

import java.io.IOException;
import java.io.InputStream;
import java.io.Reader;
import java.io.UncheckedIOException;
import java.lang.reflect.InvocationTargetException;
import java.nio.charset.Charset;
import java.nio.file.Path;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.stream.Stream;

import javax.xml.bind.JAXBException;

import org.antlr.v4.runtime.BaseErrorListener;
import org.antlr.v4.runtime.CharStream;
import org.antlr.v4.runtime.CharStreams;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.RecognitionException;
import org.antlr.v4.runtime.Recognizer;
import org.antlr.v4.runtime.misc.ParseCancellationException;
import org.antlr.v4.runtime.tree.RuleNode;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import it.bancaditalia.oss.vtl.engine.Engine;
import it.bancaditalia.oss.vtl.engine.Statement;
import it.bancaditalia.oss.vtl.grammar.Vtl;
import it.bancaditalia.oss.vtl.grammar.Vtl.StartContext;
import it.bancaditalia.oss.vtl.grammar.Vtl.StatementContext;
import it.bancaditalia.oss.vtl.grammar.VtlBaseVisitor;
import it.bancaditalia.oss.vtl.grammar.VtlTokens;
import it.bancaditalia.oss.vtl.impl.engine.mapping.OpsFactory;
import it.bancaditalia.oss.vtl.impl.engine.statement.StatementFactory;

public class JavaVTLEngine extends VtlBaseVisitor&lt;Stream&lt;Statement&gt;&gt; implements Engine
{
	private final OpsFactory opsFactory;
	private final StatementFactory statementFactory;
	@SuppressWarnings(&quot;unused&quot;)
<span class="nc" id="L61">	private final static Logger LOGGER = LoggerFactory.getLogger(JavaVTLEngine.class);</span>
	
	public JavaVTLEngine() throws ClassNotFoundException, JAXBException, IOException 
<span class="nc" id="L64">	{</span>
<span class="nc" id="L65">		opsFactory = new OpsFactory();</span>
<span class="nc" id="L66">		statementFactory = new StatementFactory(opsFactory);</span>
<span class="nc" id="L67">	}</span>
	
<span class="nc" id="L69">	public static class ThrowingErrorListener extends BaseErrorListener</span>
	{
<span class="nc" id="L71">		public static final ThrowingErrorListener INSTANCE = new ThrowingErrorListener();</span>

		@Override
		public void syntaxError(Recognizer&lt;?, ?&gt; recognizer, Object offendingSymbol, int line, int charPositionInLine, String msg, RecognitionException e)
				throws ParseCancellationException
		{
<span class="nc" id="L77">			throw new ParseCancellationException(&quot;line &quot; + line + &quot;:&quot; + charPositionInLine + &quot; &quot; + msg, e);</span>
		}
	}

	public Statement buildStatement(StatementContext ctx) throws IllegalArgumentException, IllegalAccessException, NoSuchFieldException, SecurityException, InvocationTargetException, NoSuchMethodException, ClassNotFoundException, InstantiationException
	{
<span class="nc" id="L83">		return statementFactory.createStatement(ctx);</span>
	}

	@Override
	public Stream&lt;Statement&gt; visitChildren(RuleNode node)
	{
<span class="nc bnc" id="L89" title="All 2 branches missed.">		if (node instanceof StartContext)</span>
		{
<span class="nc" id="L91">			Stream&lt;Statement&gt; result = Stream.empty();</span>
<span class="nc bnc" id="L92" title="All 2 branches missed.">			for (StatementContext ctx: ((StartContext)node).getRuleContexts(StatementContext.class))</span>
<span class="nc" id="L93">				result = Stream.concat(result, ctx.accept(this));</span>
<span class="nc" id="L94">			return result;</span>
		}
<span class="nc bnc" id="L96" title="All 2 branches missed.">		else if (node instanceof StatementContext)</span>
			try {
<span class="nc" id="L98">				return Stream.of(buildStatement((StatementContext) node));</span>
<span class="nc" id="L99">			} catch (IllegalArgumentException | IllegalAccessException | NoSuchFieldException | SecurityException | InvocationTargetException | NoSuchMethodException | ClassNotFoundException | InstantiationException cause) {</span>
<span class="nc" id="L100">				throw new RuntimeException(cause);</span>
			}
		else
<span class="nc" id="L103">			return null;</span>
	}
	
	private &lt;T&gt; Stream&lt;Statement&gt; addStatementsHelper(T statements, Function&lt;? super T, ? extends CharStream&gt; mapper) 
	{
<span class="nc" id="L108">		return parse(mapper.apply(statements));</span>
	}

	private &lt;T, U&gt; Stream&lt;Statement&gt; addStatementsHelper(T statements, U param,
			BiFunction&lt;? super T, ? super U, ? extends CharStream&gt; mapper)
	{
<span class="nc" id="L114">		return parse(mapper.apply(statements, param));</span>
	}

	private Stream&lt;Statement&gt; parse(CharStream charStream)
	{
<span class="nc" id="L119">		Vtl parser = new Vtl(new CommonTokenStream(new VtlTokens(charStream)));</span>
<span class="nc" id="L120">		parser.removeErrorListeners();</span>
<span class="nc" id="L121">		parser.addErrorListener(ThrowingErrorListener.INSTANCE);</span>
<span class="nc" id="L122">		return parser.start().accept(this);</span>
	}

	@Override
	public Stream&lt;Statement&gt; parseRules(String statements)
	{
<span class="nc" id="L128">		return addStatementsHelper(statements, CharStreams::fromString);</span>
	}

	@Override
	public Stream&lt;Statement&gt; parseRules(Reader reader) throws IOException
	{
<span class="nc" id="L134">		return addStatementsHelper(reader, arg0 -&gt; {</span>
			try
			{
<span class="nc" id="L137">				return CharStreams.fromReader(arg0);</span>
			}
<span class="nc" id="L139">			catch (IOException e)</span>
			{
<span class="nc" id="L141">				throw new UncheckedIOException(e);</span>
			}
		});
	}

	@Override
	public Stream&lt;Statement&gt; parseRules(InputStream inputStream, Charset charset) throws IOException
	{
<span class="nc" id="L149">		return addStatementsHelper(inputStream, charset, (arg0, arg1) -&gt; {</span>
			try
			{
<span class="nc" id="L152">				return CharStreams.fromStream(arg0, arg1);</span>
			}
<span class="nc" id="L154">			catch (IOException e)</span>
			{
<span class="nc" id="L156">				throw new UncheckedIOException(e);</span>
			}
		});
	}

	@Override
	public Stream&lt;Statement&gt; parseRules(Path path, Charset charset) throws IOException
	{
<span class="nc" id="L164">		return addStatementsHelper(path, charset, (t, u) -&gt; {</span>
			try
			{
<span class="nc" id="L167">				return CharStreams.fromPath(t, u);</span>
			}
<span class="nc" id="L169">			catch (IOException e)</span>
			{
<span class="nc" id="L171">				throw new UncheckedIOException(e);</span>
			}
		});
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>
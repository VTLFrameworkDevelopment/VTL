<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>REnvironment.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">vtl-envs</a> &gt; <a href="index.source.html" class="el_package">it.bancaditalia.oss.vtl.impl.environment</a> &gt; <span class="el_source">REnvironment.java</span></div><h1>REnvironment.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright 2020, Bank Of Italy
 *
 * Licensed under the EUPL, Version 1.2 (the &quot;License&quot;);
 * You may not use this work except in compliance with the
 * License.
 * You may obtain a copy of the License at:
 *
 * https://joinup.ec.europa.eu/sites/default/files/custom-page/attachment/2020-03/EUPL-1.2%20EN.txt
 *
 * Unless required by applicable law or agreed to in
 * writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; basis,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied.
 *
 * See the License for the specific language governing
 * permissions and limitations under the License.
 *******************************************************************************/
package it.bancaditalia.oss.vtl.impl.environment;

import static it.bancaditalia.oss.vtl.impl.types.domain.Domains.BOOLEAN;
import static it.bancaditalia.oss.vtl.impl.types.domain.Domains.BOOLEANDS;
import static it.bancaditalia.oss.vtl.impl.types.domain.Domains.INTEGER;
import static it.bancaditalia.oss.vtl.impl.types.domain.Domains.INTEGERDS;
import static it.bancaditalia.oss.vtl.impl.types.domain.Domains.NUMBER;
import static it.bancaditalia.oss.vtl.impl.types.domain.Domains.NUMBERDS;
import static it.bancaditalia.oss.vtl.impl.types.domain.Domains.STRING;
import static it.bancaditalia.oss.vtl.impl.types.domain.Domains.STRINGDS;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Stream;

import org.rosuda.JRI.REXP;
import org.rosuda.JRI.RList;
import org.rosuda.JRI.Rengine;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import it.bancaditalia.oss.vtl.environment.Environment;
import it.bancaditalia.oss.vtl.impl.environment.dataset.ColumnarDataSet;
import it.bancaditalia.oss.vtl.impl.types.data.BooleanValue;
import it.bancaditalia.oss.vtl.impl.types.data.DoubleValue;
import it.bancaditalia.oss.vtl.impl.types.data.IntegerValue;
import it.bancaditalia.oss.vtl.impl.types.data.NullValue;
import it.bancaditalia.oss.vtl.impl.types.data.StringValue;
import it.bancaditalia.oss.vtl.impl.types.dataset.DataStructureComponentImpl;
import it.bancaditalia.oss.vtl.impl.types.dataset.DataStructureImpl.Builder;
import it.bancaditalia.oss.vtl.model.data.ComponentRole;
import it.bancaditalia.oss.vtl.model.data.ComponentRole.Attribute;
import it.bancaditalia.oss.vtl.model.data.ComponentRole.Identifier;
import it.bancaditalia.oss.vtl.model.data.ComponentRole.Measure;
import it.bancaditalia.oss.vtl.model.data.DataSet;
import it.bancaditalia.oss.vtl.model.data.DataStructureComponent;
import it.bancaditalia.oss.vtl.model.data.ScalarValue;
import it.bancaditalia.oss.vtl.model.data.VTLValue;
import it.bancaditalia.oss.vtl.model.data.VTLValue.VTLValueMetadata;
import it.bancaditalia.oss.vtl.model.data.ValueDomainSubset;
import it.bancaditalia.oss.vtl.util.Utils;

<span class="nc" id="L66">class REnvironment implements Environment</span>
{
<span class="nc" id="L68">	private final static Logger LOGGER = LoggerFactory.getLogger(REnvironment.class);</span>
<span class="nc" id="L69">	private final Map&lt;String, VTLValue&gt;	values	= new HashMap&lt;&gt;();</span>
	private Rengine						rengine;

	public Rengine getREngine()
	{
<span class="nc" id="L74">		return rengine;</span>
	}

	private boolean isEnabled()
	{
<span class="nc bnc" id="L79" title="All 2 branches missed.">		return !&quot;disable&quot;.equalsIgnoreCase(System.getProperty(&quot;vtl.r&quot;));</span>
	}
	
	@Override
	public Optional&lt;? extends VTLValueMetadata&gt; getValueMetadata(String name)
	{
<span class="nc bnc" id="L85" title="All 2 branches missed.">		if (!isEnabled())</span>
<span class="nc" id="L86">			return Optional.empty();</span>
		
<span class="nc bnc" id="L88" title="All 2 branches missed.">		if (values.containsKey(name))</span>
<span class="nc" id="L89">			return Optional.of(values.get(name).getMetadata());</span>

<span class="nc bnc" id="L91" title="All 2 branches missed.">		if (rengine.eval(&quot;exists('&quot; + name + &quot;')&quot;).asBool().isTRUE())</span>
		{
<span class="nc bnc" id="L93" title="All 2 branches missed.">			if (rengine.eval(&quot;is.data.frame(&quot; + name + &quot;)&quot;).asBool().isTRUE()) </span>
			{
<span class="nc" id="L95">				REXP data = rengine.eval(name + &quot;[1,]&quot;);</span>
<span class="nc" id="L96">				RList dataFrame = data.asList();</span>

				// manage measure and identifier attributes
<span class="nc" id="L99">				List&lt;String&gt; measures = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L100">				REXP measureAttrs = data.getAttribute(&quot;measures&quot;);</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">				if(measureAttrs != null) {</span>
<span class="nc" id="L102">					measures = Arrays.asList(measureAttrs.asStringArray());</span>
				}
				
<span class="nc" id="L105">				List&lt;String&gt; identifiers = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L106">				REXP idAttr = data.getAttribute(&quot;identifiers&quot;);</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">				if(idAttr != null) {</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">					if (rengine.eval(&quot;any(duplicated(&quot; + name + &quot;[,attr(&quot; + name + &quot;, 'identifiers')]))&quot;).asBool().isTRUE())</span>
<span class="nc" id="L109">						throw new IllegalStateException(&quot;Found duplicated rows in data frame &quot; + name);</span>
<span class="nc" id="L110">					identifiers = Arrays.asList(idAttr.asStringArray());</span>
				}
				
<span class="nc" id="L113">				Builder builder = new Builder();</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">				for (String key: dataFrame.keys())</span>
				{
<span class="nc" id="L116">					REXP columnData = dataFrame.at(key);</span>

					Class&lt;? extends ComponentRole&gt; type;
<span class="nc bnc" id="L119" title="All 2 branches missed.">					if (measures.contains(key))</span>
<span class="nc" id="L120">						type = Measure.class;</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">					else if (identifiers.contains(key))</span>
<span class="nc" id="L122">						type = Identifier.class;</span>
					else
<span class="nc" id="L124">						type = Attribute.class;</span>

					ValueDomainSubset&lt;?&gt; domain;
<span class="nc bnc" id="L127" title="All 5 branches missed.">					switch (columnData.getType())</span>
					{
						case REXP.XT_DOUBLE: case REXP.XT_ARRAY_DOUBLE:
<span class="nc" id="L130">							domain = NUMBERDS;</span>
<span class="nc" id="L131">							break;</span>
						case REXP.XT_INT: case REXP.XT_ARRAY_INT:
<span class="nc" id="L133">							domain = INTEGERDS;</span>
<span class="nc" id="L134">							break;</span>
						case REXP.XT_STR: case REXP.XT_ARRAY_STR:
<span class="nc" id="L136">							domain = STRINGDS;</span>
<span class="nc" id="L137">							break;</span>
						case REXP.XT_BOOL: case REXP.XT_ARRAY_BOOL: case REXP.XT_ARRAY_BOOL_INT:
<span class="nc" id="L139">							domain = BOOLEANDS;</span>
<span class="nc" id="L140">							break;</span>
						default:
<span class="nc" id="L142">							throw new UnsupportedOperationException(</span>
<span class="nc" id="L143">									&quot;Unrecognized data.frame column type in &quot; + name + &quot;: &quot; + key + &quot;(&quot; + REXP.xtName(columnData.getType()) + &quot;)&quot;);</span>
					}
					
<span class="nc" id="L146">					builder.addComponent(key, type, domain);</span>
				}
				
<span class="nc" id="L149">				return Optional.of(builder.build());</span>
			}
<span class="nc" id="L151">			else if (rengine.eval(&quot;is.integer(&quot; + name + &quot;) || is.numeric(&quot; + name + &quot;) || is.character(&quot; + name + &quot;) || is.logical(&quot; + name + &quot;)&quot;)</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">					.asBool().isTRUE())</span>
			{
<span class="nc" id="L154">				REXP data = rengine.eval(name);</span>
<span class="nc bnc" id="L155" title="All 5 branches missed.">				switch (data.getType())</span>
				{
					case REXP.XT_STR:
<span class="nc" id="L158">						return Optional.of(STRING);</span>
					case REXP.XT_ARRAY_DOUBLE:
<span class="nc" id="L160">						return Optional.of(NUMBER);</span>
					case REXP.XT_ARRAY_INT:
<span class="nc" id="L162">						return Optional.of(INTEGER);</span>
					case REXP.XT_ARRAY_BOOL: case REXP.XT_ARRAY_BOOL_INT:
<span class="nc" id="L164">						return Optional.of(BOOLEAN);</span>
					default:
<span class="nc" id="L166">						throw new UnsupportedOperationException(</span>
<span class="nc" id="L167">								&quot;Unrecognized scalar value &quot; + name + &quot;: &quot; + REXP.xtName(data.getType()) + &quot;)&quot;);</span>
				}
			}
		}

<span class="nc" id="L172">		return Optional.empty();</span>
	}
	
	@Override
	public Optional&lt;VTLValue&gt; getValue(String name)
	{
<span class="nc bnc" id="L178" title="All 2 branches missed.">		if (!isEnabled())</span>
<span class="nc" id="L179">			return Optional.empty();</span>
		
<span class="nc bnc" id="L181" title="All 2 branches missed.">		if (values.containsKey(name))</span>
<span class="nc" id="L182">			return Optional.of(values.get(name));</span>

<span class="nc bnc" id="L184" title="All 2 branches missed.">		if (rengine.eval(&quot;exists('&quot; + name + &quot;')&quot;).asBool().isTRUE())</span>
		{
			VTLValue result;

<span class="nc bnc" id="L188" title="All 2 branches missed.">			if (rengine.eval(&quot;is.data.frame(&quot; + name + &quot;)&quot;).asBool().isTRUE()) {</span>
<span class="nc" id="L189">				result = parseDataFrame(name);</span>
<span class="nc" id="L190">				values.put(name, result);</span>
<span class="nc" id="L191">				return Optional.of(result);</span>
			}
<span class="nc" id="L193">			else if (rengine.eval(&quot;is.integer(&quot; + name + &quot;) || is.numeric(&quot; + name + &quot;) || is.character(&quot; + name +</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">					&quot;)&quot;).asBool().isTRUE())</span>
			{
<span class="nc" id="L196">				REXP data = rengine.eval(name);</span>
<span class="nc bnc" id="L197" title="All 5 branches missed.">				switch (data.getType())</span>
				{
					case REXP.XT_STR:
<span class="nc" id="L200">						result = new StringValue(data.asString());</span>
<span class="nc" id="L201">						break;</span>
					case REXP.XT_ARRAY_DOUBLE:
<span class="nc" id="L203">						result = new DoubleValue(data.asDoubleArray()[0]);</span>
<span class="nc" id="L204">						break;</span>
					case REXP.XT_ARRAY_INT:
<span class="nc" id="L206">						result = new IntegerValue((long) data.asIntArray()[0]);</span>
<span class="nc" id="L207">						break;</span>
					case REXP.XT_ARRAY_BOOL: case REXP.XT_ARRAY_BOOL_INT:
<span class="nc bnc" id="L209" title="All 2 branches missed.">						result = data.asBool().isNA() ? NullValue.instance(BOOLEANDS) : BooleanValue.of(data.asBool().isTRUE());</span>
<span class="nc" id="L210">						break;</span>
					default:
<span class="nc" id="L212">						throw new IllegalStateException(&quot;Node: &quot; + name + &quot; of scalar type: &quot; + REXP.xtName(data.getType()) + &quot;. This is not supported.&quot;);</span>
				}
<span class="nc" id="L214">				values.put(name, result);</span>
<span class="nc" id="L215">				return Optional.of(result);</span>
			}
		}

<span class="nc" id="L219">		return Optional.empty();</span>
	}

	private DataSet parseDataFrame(String name)
	{
<span class="nc bnc" id="L224" title="All 2 branches missed.">		if (!isEnabled())</span>
<span class="nc" id="L225">			return null;</span>
		
<span class="nc" id="L227">		List&lt;String&gt; identifiers = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L228">		List&lt;String&gt; measures = new ArrayList&lt;&gt;();</span>

		// transform factors into strings
<span class="nc" id="L231">		rengine.eval(&quot;if(any(sapply(&quot; + name + &quot;, is.factor))) &quot; + name + &quot;[which(sapply(&quot; + name + &quot;, is.factor))] &lt;- sapply(&quot; + name + &quot;[which(sapply(&quot; + name</span>
				+ &quot;, is.factor))], as.character)&quot;);

<span class="nc" id="L234">		LOGGER.info(&quot;Migrating dataset {} from R&quot;, name);</span>
		
<span class="nc" id="L236">		REXP data = rengine.eval(name);</span>
<span class="nc" id="L237">		RList dataFrame = data.asList();</span>

		// manage measure and identifier attributes
<span class="nc" id="L240">		REXP measureAttr = data.getAttribute(&quot;measures&quot;);</span>
<span class="nc bnc" id="L241" title="All 6 branches missed.">		if (measureAttr != null &amp;&amp; (measureAttr.getType() == REXP.XT_ARRAY_STR || measureAttr.getType() == REXP.XT_STR))</span>
<span class="nc" id="L242">			measures = Arrays.asList(measureAttr.asStringArray());</span>

<span class="nc" id="L244">		REXP idAttr = data.getAttribute(&quot;identifiers&quot;);</span>
<span class="nc bnc" id="L245" title="All 6 branches missed.">		if (idAttr != null &amp;&amp; (idAttr.getType() == REXP.XT_ARRAY_STR || idAttr.getType() == REXP.XT_STR))</span>
<span class="nc" id="L246">			identifiers = Arrays.asList(idAttr.asStringArray());</span>

<span class="nc" id="L248">		Map&lt;DataStructureComponent&lt;?, ?, ?&gt;, ScalarValue&lt;?, ?, ?&gt;[]&gt; dataContainer = new HashMap&lt;&gt;();</span>
		// get column data
<span class="nc bnc" id="L250" title="All 2 branches missed.">		for (String key: dataFrame.keys())</span>
		{
<span class="nc" id="L252">			REXP columnData = dataFrame.at(key);</span>

			Class&lt;? extends ComponentRole&gt; type;
<span class="nc bnc" id="L255" title="All 2 branches missed.">			if (measures.contains(key))</span>
<span class="nc" id="L256">				type = Measure.class;</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">			else if (identifiers.contains(key))</span>
<span class="nc" id="L258">				type = Identifier.class;</span>
			else
<span class="nc" id="L260">				type = Attribute.class;</span>

			Stream&lt;? extends ScalarValue&lt;?, ?, ?&gt;&gt; values;
			ValueDomainSubset&lt;?&gt; domain;
<span class="nc bnc" id="L264" title="All 5 branches missed.">			switch (columnData.getType())</span>
			{
				case REXP.XT_ARRAY_DOUBLE:
<span class="nc" id="L267">					domain = NUMBERDS;</span>
<span class="nc" id="L268">					values = Utils.getStream(columnData.asDoubleArray()).mapToObj(DoubleValue::new);</span>
<span class="nc" id="L269">					break;</span>
				case REXP.XT_ARRAY_INT:
<span class="nc" id="L271">					domain = INTEGERDS;</span>
<span class="nc" id="L272">					values = Utils.getStream(columnData.asIntArray()).asLongStream().mapToObj(IntegerValue::new);</span>
<span class="nc" id="L273">					break;</span>
				case REXP.XT_ARRAY_STR:
<span class="nc" id="L275">					domain = STRINGDS;</span>
<span class="nc" id="L276">					values = Utils.getStream(columnData.asStringArray()).map(StringValue::new);</span>
<span class="nc" id="L277">					break;</span>
				case REXP.XT_ARRAY_BOOL: case REXP.XT_ARRAY_BOOL_INT:
<span class="nc" id="L279">					domain = BOOLEANDS;</span>
<span class="nc bnc" id="L280" title="All 4 branches missed.">					values = Utils.getStream(columnData.asIntArray()).mapToObj(val -&gt; (ScalarValue&lt;?, ?, ?&gt;) (val == 2 ? NullValue.instance(BOOLEANDS) : BooleanValue.of(val == 1)));</span>
<span class="nc" id="L281">					break;</span>
				default:
<span class="nc" id="L283">					throw new IllegalStateException(</span>
<span class="nc" id="L284">							&quot;In node: &quot; + name + &quot; there is a column (&quot; + key + &quot;) of type &quot; + REXP.xtName(columnData.getType()) + &quot;. This is not supported.&quot;);</span>
			}
			
<span class="nc" id="L287">			dataContainer.put(new DataStructureComponentImpl&lt;&gt;(key, type, domain), values.toArray(ScalarValue&lt;?, ?, ?&gt;[]::new));</span>
		}
		
<span class="nc" id="L290">		return new ColumnarDataSet(dataContainer);</span>
	}

	@Override
	public boolean contains(String id)
	{
<span class="nc" id="L296">		return values.containsKey(id);</span>
	}

	@Override
	public Environment init(Object... rengine)
	{
<span class="nc bnc" id="L302" title="All 2 branches missed.">		if (isEnabled())</span>
<span class="nc bnc" id="L303" title="All 4 branches missed.">			this.rengine = (rengine == null || rengine[0] == null) ? new Rengine() : (Rengine) rengine[0];</span>
		
<span class="nc" id="L305">		return this;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>
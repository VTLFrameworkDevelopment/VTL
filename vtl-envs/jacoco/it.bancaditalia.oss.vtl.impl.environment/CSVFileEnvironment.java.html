<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CSVFileEnvironment.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">vtl-envs</a> &gt; <a href="index.source.html" class="el_package">it.bancaditalia.oss.vtl.impl.environment</a> &gt; <span class="el_source">CSVFileEnvironment.java</span></div><h1>CSVFileEnvironment.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright 2020, Bank Of Italy
 *
 * Licensed under the EUPL, Version 1.2 (the &quot;License&quot;);
 * You may not use this work except in compliance with the
 * License.
 * You may obtain a copy of the License at:
 *
 * https://joinup.ec.europa.eu/sites/default/files/custom-page/attachment/2020-03/EUPL-1.2%20EN.txt
 *
 * Unless required by applicable law or agreed to in
 * writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; basis,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied.
 *
 * See the License for the specific language governing
 * permissions and limitations under the License.
 *******************************************************************************/
package it.bancaditalia.oss.vtl.impl.environment;

import static it.bancaditalia.oss.vtl.impl.types.domain.Domains.BOOLEANDS;
import static it.bancaditalia.oss.vtl.impl.types.domain.Domains.DATEDS;
import static it.bancaditalia.oss.vtl.impl.types.domain.Domains.INTEGERDS;
import static it.bancaditalia.oss.vtl.impl.types.domain.Domains.NUMBERDS;
import static it.bancaditalia.oss.vtl.impl.types.domain.Domains.STRINGDS;
import static java.lang.Boolean.TRUE;
import static java.nio.charset.StandardCharsets.UTF_8;
import static java.time.temporal.ChronoField.DAY_OF_MONTH;
import static java.time.temporal.ChronoField.HOUR_OF_DAY;
import static java.time.temporal.ChronoField.MINUTE_OF_HOUR;
import static java.time.temporal.ChronoField.MONTH_OF_YEAR;
import static java.time.temporal.ChronoField.SECOND_OF_MINUTE;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.UncheckedIOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeFormatterBuilder;
import java.util.AbstractMap.SimpleEntry;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.concurrent.ConcurrentHashMap;
import java.util.Optional;
import java.util.function.Supplier;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Stream;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import it.bancaditalia.oss.vtl.environment.Environment;
import it.bancaditalia.oss.vtl.exceptions.VTLException;
import it.bancaditalia.oss.vtl.exceptions.VTLNestedException;
import it.bancaditalia.oss.vtl.impl.types.data.BooleanValue;
import it.bancaditalia.oss.vtl.impl.types.data.DateValue;
import it.bancaditalia.oss.vtl.impl.types.data.DoubleValue;
import it.bancaditalia.oss.vtl.impl.types.data.IntegerValue;
import it.bancaditalia.oss.vtl.impl.types.data.NullValue;
import it.bancaditalia.oss.vtl.impl.types.data.StringValue;
import it.bancaditalia.oss.vtl.impl.types.dataset.DataPointImpl.DataPointBuilder;
import it.bancaditalia.oss.vtl.impl.types.dataset.DataStructureComponentImpl;
import it.bancaditalia.oss.vtl.impl.types.dataset.DataStructureImpl.Builder;
import it.bancaditalia.oss.vtl.impl.types.dataset.LightDataSet;
import it.bancaditalia.oss.vtl.model.data.ComponentRole;
import it.bancaditalia.oss.vtl.model.data.ComponentRole.Attribute;
import it.bancaditalia.oss.vtl.model.data.ComponentRole.Identifier;
import it.bancaditalia.oss.vtl.model.data.ComponentRole.Measure;
import it.bancaditalia.oss.vtl.model.data.DataPoint;
import it.bancaditalia.oss.vtl.model.data.DataSet.VTLDataSetMetadata;
import it.bancaditalia.oss.vtl.model.data.DataStructureComponent;
import it.bancaditalia.oss.vtl.model.data.ScalarValue;
import it.bancaditalia.oss.vtl.model.data.VTLValue;
import it.bancaditalia.oss.vtl.model.data.VTLValue.VTLValueMetadata;
import it.bancaditalia.oss.vtl.model.data.ValueDomain;
import it.bancaditalia.oss.vtl.model.data.ValueDomainSubset;
import it.bancaditalia.oss.vtl.model.domain.BooleanDomainSubset;
import it.bancaditalia.oss.vtl.model.domain.DateDomain;
import it.bancaditalia.oss.vtl.model.domain.DateDomainSubset;
import it.bancaditalia.oss.vtl.model.domain.IntegerDomainSubset;
import it.bancaditalia.oss.vtl.model.domain.NumberDomainSubset;
import it.bancaditalia.oss.vtl.model.domain.StringDomainSubset;
import it.bancaditalia.oss.vtl.util.ProgressWindow;
import it.bancaditalia.oss.vtl.util.Utils;

<span class="fc" id="L97">public class CSVFileEnvironment implements Environment</span>
{
<span class="fc" id="L99">	private static final Logger LOGGER = LoggerFactory.getLogger(CSVFileEnvironment.class);</span>

<span class="fc" id="L101">	private final static Map&lt;Pattern, String&gt; PATTERNS = new LinkedHashMap&lt;&gt;();</span>
	
	static {
<span class="fc" id="L104">		PATTERNS.put(Pattern.compile(&quot;^(YYYY)(.*)$&quot;), &quot;yyyy&quot;);</span>
<span class="fc" id="L105">		PATTERNS.put(Pattern.compile(&quot;^(YYY)(.*)$&quot;), &quot;yyy&quot;);</span>
<span class="fc" id="L106">		PATTERNS.put(Pattern.compile(&quot;^(YY)(.*)$&quot;), &quot;yy&quot;);</span>
<span class="fc" id="L107">		PATTERNS.put(Pattern.compile(&quot;^(M[Oo][Nn][Tt][Hh]3)(.*)$&quot;), &quot;LLL&quot;);</span>
<span class="fc" id="L108">		PATTERNS.put(Pattern.compile(&quot;^(M[Oo][Nn][Tt][Hh]1)(.*)$&quot;), &quot;LLLLL&quot;);</span>
<span class="fc" id="L109">		PATTERNS.put(Pattern.compile(&quot;^(D[Aa][Yy]3)(.*)$&quot;), &quot;ccc&quot;);</span>
<span class="fc" id="L110">		PATTERNS.put(Pattern.compile(&quot;^(D[Aa][Yy]1)(.*)$&quot;), &quot;ccccc&quot;);</span>
<span class="fc" id="L111">		PATTERNS.put(Pattern.compile(&quot;^(MM)(.*)$&quot;), &quot;MM&quot;);</span>
<span class="fc" id="L112">		PATTERNS.put(Pattern.compile(&quot;^(M)(.*)$&quot;), &quot;M&quot;);</span>
<span class="fc" id="L113">		PATTERNS.put(Pattern.compile(&quot;^(DD)(.*)$&quot;), &quot;dd&quot;);</span>
<span class="fc" id="L114">		PATTERNS.put(Pattern.compile(&quot;^(D)(.*)$&quot;), &quot;d&quot;);</span>
<span class="fc" id="L115">		PATTERNS.put(Pattern.compile(&quot;^([-/ ])(.*)$&quot;), &quot;$1&quot;);</span>
<span class="fc" id="L116">	}</span>

	@Override
	public boolean contains(String name)
	{
<span class="pc bpc" id="L121" title="2 of 4 branches missed.">		return name.startsWith(&quot;csv:&quot;) &amp;&amp; Files.exists(Paths.get(name.substring(4)));</span>
	}

	@Override
	public Optional&lt;? extends VTLValue&gt; getValue(String name)
	{
<span class="pc bpc" id="L127" title="1 of 2 branches missed.">		if (!contains(name))</span>
<span class="nc" id="L128">			return Optional.empty();</span>

<span class="fc" id="L130">		String fileName = name.substring(4);</span>
		
<span class="fc" id="L132">		LOGGER.debug(&quot;Looking for csv file '{}'&quot;, fileName);</span>

		List&lt;DataStructureComponent&lt;?, ?, ?&gt;&gt; metadata;
<span class="fc" id="L135">		try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(fileName), StandardCharsets.UTF_8)))</span>
		{
			// can't use streams, must be ordered for the first line processed to be actually the header 
<span class="fc" id="L138">			String headers[] = reader.readLine().substring(3).split(&quot;,&quot;);</span>
<span class="fc" id="L139">			metadata = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L140">			Map&lt;DataStructureComponent&lt;?, ?, ?&gt;, String&gt; masks = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">			for (String header: headers)</span>
			{
<span class="fc" id="L143">				String cname = header.split(&quot;=&quot;, 2)[0];</span>
<span class="fc" id="L144">				String typeName = header.split(&quot;=&quot;, 2)[1];</span>
				
<span class="fc" id="L146">				Entry&lt;ValueDomainSubset&lt;? extends ValueDomain&gt;, String&gt; mappedType = mapVarType(typeName);</span>
<span class="fc" id="L147">				ValueDomainSubset&lt;? extends ValueDomain&gt; domain = mappedType.getKey();</span>
<span class="fc bfc" id="L148" title="All 4 branches covered.">				Class&lt;? extends ComponentRole&gt; role = cname.startsWith(&quot;$&quot;) ? Identifier.class : cname.startsWith(&quot;#&quot;) ? Attribute.class : Measure.class;</span>
<span class="fc" id="L149">				cname = cname.replaceAll(&quot;^[$#]&quot;, &quot;&quot;);</span>
<span class="fc" id="L150">				DataStructureComponentImpl&lt;? extends ComponentRole, ?, ? extends ValueDomain&gt; component = new DataStructureComponentImpl&lt;&gt;(cname, role, domain);</span>
<span class="fc" id="L151">				metadata.add(component);</span>
				
<span class="fc bfc" id="L153" title="All 2 branches covered.">				if (domain instanceof DateDomain)</span>
<span class="fc" id="L154">					masks.put(component, mappedType.getValue());</span>
			}
			
<span class="fc" id="L157">			LOGGER.info(&quot;Reading {}&quot;, fileName);</span>
			
<span class="fc" id="L159">			final VTLDataSetMetadata structure = new Builder(metadata).build();</span>
			
<span class="fc" id="L161">			int lineCount = (int) Utils.getStream(Files.lines(Paths.get(fileName), UTF_8)).count();</span>
<span class="fc" id="L162">			Supplier&lt;Stream&lt;DataPoint&gt;&gt; datapoints = () -&gt; {</span>
				try {
<span class="fc" id="L164">					Map&lt;Map&lt;DataStructureComponent&lt;Identifier, ?, ?&gt;, ScalarValue&lt;?, ?, ?&gt;&gt;, Boolean&gt; set = new ConcurrentHashMap&lt;&gt;();</span>
					
<span class="fc" id="L166">					return ProgressWindow.of(&quot;Loading CSV&quot;, lineCount, </span>
<span class="fc" id="L167">							Utils.getStream(Files.lines(Paths.get(fileName), UTF_8)))</span>
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">						.filter(l -&gt; !l.trim().isEmpty())</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">						.filter(l -&gt; !l.startsWith(&quot;--&gt;&quot;))</span>
<span class="fc" id="L170">						.map(l -&gt; {</span>
<span class="fc" id="L171">							Map&lt;DataStructureComponent&lt;?, ?, ?&gt;, ScalarValue&lt;?, ?, ?&gt;&gt; result = new HashMap&lt;&gt;();</span>
<span class="fc" id="L172">							int beginIndex = 0;</span>
<span class="fc bfc" id="L173" title="All 2 branches covered.">							for (int i = 0; i &lt; metadata.size(); i++)</span>
							{
<span class="fc" id="L175">								DataStructureComponent&lt;?, ?, ?&gt; component = metadata.get(i);</span>
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">								if (beginIndex &gt;= l.length())</span>
<span class="nc" id="L177">									throw new IllegalStateException(&quot;Expected value for &quot; + component + &quot; but row ended before: &quot; + l);</span>
									
<span class="fc" id="L179">								int endIndex = l.indexOf(',', beginIndex);</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">								if (endIndex &lt; 0)</span>
<span class="fc" id="L181">									endIndex = l.length();</span>
<span class="fc" id="L182">								result.put(component, mapValue(component, l.substring(beginIndex, endIndex), masks.get(component)));</span>
<span class="fc" id="L183">								beginIndex = endIndex + 1;</span>
							}

<span class="fc" id="L186">							return result;</span>
						})
<span class="fc" id="L188">						.map(m -&gt; new DataPointBuilder(m).build(structure))</span>
<span class="fc" id="L189">						.peek(dp -&gt; {</span>
<span class="fc" id="L190">							Map&lt;DataStructureComponent&lt;Identifier, ?, ?&gt;, ScalarValue&lt;?, ?, ?&gt;&gt; values = dp.getValues(Identifier.class);</span>
<span class="fc" id="L191">							Boolean a = set.putIfAbsent(values, TRUE);</span>
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">							if (a != null)</span>
<span class="nc" id="L193">								throw new IllegalStateException(&quot;Identifiers are not unique: &quot; + values);</span>
<span class="fc" id="L194">						});</span>
<span class="nc" id="L195">				} catch (IOException e) {</span>
<span class="nc" id="L196">					throw new UncheckedIOException(e);</span>
				}
			};
<span class="fc" id="L199">			return Optional.of(new LightDataSet(structure, datapoints));</span>
		}
<span class="nc" id="L201">		catch (IOException /*| ReflectiveOperationException */ e)</span>
		{
<span class="nc" id="L203">			throw new VTLNestedException(&quot;Exception while reading &quot; + fileName, e);</span>
		}
	}

	private ScalarValue&lt;?, ?, ?&gt; mapValue(DataStructureComponent&lt;?, ?, ?&gt; component, final String value, String mask)
	{
<span class="fc bfc" id="L209" title="All 2 branches covered.">		if (component.getDomain() instanceof StringDomainSubset)</span>
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">			return new StringValue(value.matches(&quot;^\&quot;.*\&quot;$&quot;) ? value.substring(1, value.length() - 1) : value);</span>
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">		else if (component.getDomain() instanceof IntegerDomainSubset)</span>
			try
			{
<span class="nc bnc" id="L214" title="All 2 branches missed.">				if (value.trim().isEmpty())</span>
<span class="nc" id="L215">					return NullValue.instance(INTEGERDS);</span>
				else
<span class="nc" id="L217">					return new IntegerValue(Long.parseLong(value));</span>
			}
<span class="nc" id="L219">			catch (NumberFormatException e)</span>
			{
<span class="nc" id="L221">				LOGGER.error(&quot;An Integer was expected but found: &quot; + value);</span>
<span class="nc" id="L222">				return NullValue.instance(INTEGERDS);</span>
			}
<span class="fc bfc" id="L224" title="All 2 branches covered.">		else if (component.getDomain() instanceof NumberDomainSubset)</span>
			try
			{
<span class="pc bpc" id="L227" title="1 of 2 branches missed.">				if (value.trim().isEmpty())</span>
<span class="nc" id="L228">					return NullValue.instance(NUMBERDS);</span>
				else
<span class="fc" id="L230">					return new DoubleValue(Double.parseDouble(value));</span>
			}
<span class="nc" id="L232">			catch (NumberFormatException e)</span>
			{
<span class="nc" id="L234">				LOGGER.error(&quot;A Number was expected but found: &quot; + value);</span>
<span class="nc" id="L235">				return NullValue.instance(NUMBERDS);</span>
			}
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">		else if (component.getDomain() instanceof BooleanDomainSubset)</span>
<span class="nc" id="L238">			return BooleanValue.of(Boolean.parseBoolean(value));</span>
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">		else if (component.getDomain() instanceof DateDomainSubset)</span>
		{
<span class="fc" id="L241">			StringBuilder maskBuilder = new StringBuilder();</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">			while (!mask.isEmpty())</span>
			{
<span class="fc" id="L244">				boolean found = false;</span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">				for (Pattern pattern: PATTERNS.keySet())</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">					if (!found)</span>
					{
<span class="fc" id="L248">						Matcher matcher = pattern.matcher(mask);</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">						if (matcher.find())</span>
						{
<span class="fc" id="L251">							maskBuilder.append(matcher.replaceFirst(PATTERNS.get(pattern)));</span>
<span class="fc" id="L252">							mask = matcher.group(2);</span>
<span class="fc" id="L253">							found = true;</span>
						}
					}
				
<span class="pc bpc" id="L257" title="1 of 2 branches missed.">				if (!found)</span>
<span class="nc" id="L258">					throw new IllegalStateException(&quot;Unrecognized mask in cast operator: &quot; + mask);</span>
<span class="fc" id="L259">			}</span>

<span class="fc" id="L261">			DateTimeFormatter formatter = new DateTimeFormatterBuilder()</span>
<span class="fc" id="L262">				.appendPattern(maskBuilder.toString())</span>
<span class="fc" id="L263">				.parseDefaulting(MONTH_OF_YEAR, 1)</span>
<span class="fc" id="L264">				.parseDefaulting(DAY_OF_MONTH, 1)</span>
<span class="fc" id="L265">				.parseDefaulting(HOUR_OF_DAY, 0)</span>
<span class="fc" id="L266">	            .parseDefaulting(MINUTE_OF_HOUR, 0)</span>
<span class="fc" id="L267">	            .parseDefaulting(SECOND_OF_MINUTE, 0)</span>
<span class="fc" id="L268">	            .toFormatter();</span>
<span class="fc" id="L269">			return new DateValue(LocalDateTime.parse(value, formatter));</span>
		}

<span class="nc" id="L272">		throw new IllegalStateException(&quot;Unknown value type: &quot; + component.getDomain());</span>
	}

	private static Entry&lt;ValueDomainSubset&lt;? extends ValueDomain&gt;, String&gt; mapVarType(String typeName)
	{
<span class="fc" id="L277">		String datePattern = &quot;^[Dd][Aa][Tt][Ee]\\[(.*)\\]$&quot;;</span>
		
<span class="fc bfc" id="L279" title="All 2 branches covered.">		if (&quot;STRING&quot;.equalsIgnoreCase(typeName))</span>
<span class="fc" id="L280">			return new SimpleEntry&lt;&gt;(STRINGDS, &quot;&quot;);</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">		else if (&quot;NUMBER&quot;.equalsIgnoreCase(typeName))</span>
<span class="fc" id="L282">			return new SimpleEntry&lt;&gt;(NUMBERDS, &quot;&quot;);</span>
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">		else if (&quot;INT&quot;.equalsIgnoreCase(typeName))</span>
<span class="nc" id="L284">			return new SimpleEntry&lt;&gt;(INTEGERDS, &quot;&quot;);</span>
<span class="pc bpc" id="L285" title="1 of 2 branches missed.">		else if (&quot;BOOL&quot;.equalsIgnoreCase(typeName))</span>
<span class="nc" id="L286">			return new SimpleEntry&lt;&gt;(BOOLEANDS, &quot;&quot;);</span>
<span class="pc bpc" id="L287" title="1 of 2 branches missed.">		else if (typeName.matches(datePattern))</span>
<span class="fc" id="L288">			return new SimpleEntry&lt;&gt;(DATEDS, typeName.replaceAll(datePattern, &quot;$1&quot;));</span>

<span class="nc" id="L290">		throw new VTLException(&quot;Unsupported type: &quot; + typeName);</span>
	}

	@Override
	public Optional&lt;? extends VTLValueMetadata&gt; getValueMetadata(String name)
	{
<span class="nc bnc" id="L296" title="All 2 branches missed.">		if (!contains(name))</span>
<span class="nc" id="L297">			return Optional.empty();</span>

<span class="nc" id="L299">		String fileName = name.substring(4);</span>

<span class="nc" id="L301">		LOGGER.debug(&quot;Looking for csv file '{}'&quot;, fileName);</span>

<span class="nc" id="L303">		try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(fileName), StandardCharsets.UTF_8)))</span>
		{
			// must be ordered
<span class="nc" id="L306">			String headers[] = reader.readLine().substring(3).split(&quot;,&quot;);</span>
<span class="nc" id="L307">			List&lt;DataStructureComponent&lt;?, ?, ?&gt;&gt; metadata = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L308">			Map&lt;DataStructureComponent&lt;?, ?, ?&gt;, String&gt; patterns = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">			for (String header: headers)</span>
			{
<span class="nc" id="L311">				String cname = header.split(&quot;=&quot;, 2)[0];</span>
<span class="nc" id="L312">				String typeName = header.split(&quot;=&quot;, 2)[1];</span>
				
<span class="nc" id="L314">				Entry&lt;ValueDomainSubset&lt;? extends ValueDomain&gt;, String&gt; mappedType = mapVarType(typeName);</span>
<span class="nc" id="L315">				ValueDomainSubset&lt;? extends ValueDomain&gt; domain = mappedType.getKey();</span>
<span class="nc bnc" id="L316" title="All 4 branches missed.">				Class&lt;? extends ComponentRole&gt; role = cname.startsWith(&quot;$&quot;) ? Identifier.class : cname.startsWith(&quot;#&quot;) ? Attribute.class : Measure.class;</span>
<span class="nc" id="L317">				cname = cname.replaceAll(&quot;^[$#]&quot;, &quot;&quot;);</span>
<span class="nc" id="L318">				DataStructureComponentImpl&lt;? extends ComponentRole, ?, ? extends ValueDomain&gt; component = new DataStructureComponentImpl&lt;&gt;(cname, role, domain);</span>
<span class="nc" id="L319">				metadata.add(component);</span>
				
<span class="nc bnc" id="L321" title="All 2 branches missed.">				if (domain instanceof DateDomain)</span>
<span class="nc" id="L322">					patterns.put(component, mappedType.getValue());</span>
			}
			
<span class="nc" id="L325">			return Optional.of(new Builder(metadata).build());</span>
		}
<span class="nc" id="L327">		catch (IOException e)</span>
		{
<span class="nc" id="L329">			throw new VTLNestedException(&quot;Exception while reading &quot; + fileName, e);</span>
		}
	}
	
	/*private static class MemoryMapper implements Spliterator&lt;String&gt;
	{
		private static final long MAXSIZE = Integer.MAX_VALUE; // 64MB
		private static final Logger LOGGER = LoggerFactory.getLogger(MemoryMapper.class);
		
		private final CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder();
		private final FileChannel channel;
		private final long size;
		private final CharBuffer out = CharBuffer.allocate(1024 * 1024);
		private final BlockingQueue&lt;String&gt; queue = new LinkedBlockingQueue&lt;&gt;(10000);
		private final AtomicInteger counter = new AtomicInteger();
		private final int lines;
		
		private MappedByteBuffer buffer = null;
		private long lastPosition = 0;
		private CoderResult lastDecodeResult = null;
		private int splits = 1;

		@SuppressWarnings(&quot;resource&quot;)
		public MemoryMapper(String name, int lines) throws IOException
		{
			this.lines = lines;
			this.channel = new RandomAccessFile(name, &quot;r&quot;).getChannel();
			size = channel.size();
			fill();
			final Thread producer = new Thread(this::producer, &quot;Reader thread for &quot; + name);
			producer.setDaemon(true);
			producer.start();
		}
		
		private void fill() throws IOException 
		{
			long toRead = size - lastPosition;
			if (buffer != null &amp;&amp; buffer.hasRemaining())
			{
				out.clear();
				lastDecodeResult = decoder.decode(buffer, out, false);
				if (lastDecodeResult.isError())
					lastDecodeResult.throwException();
				out.flip();
			}
			else if (toRead &gt; 0)
			{
				if (toRead &gt; MAXSIZE)
					toRead = MAXSIZE;
				
				buffer = channel.map(FileChannel.MapMode.READ_ONLY, lastPosition, toRead);
				lastPosition += toRead;
				LOGGER.trace(&quot;Read {} bytes&quot;, toRead);
				out.clear();
				lastDecodeResult = decoder.decode(buffer, out, false);
				out.flip();
				if (lastDecodeResult.isError())
					lastDecodeResult.throwException();
			}
			else if (lastPosition &gt;= size)
			{
				out.clear();
				lastDecodeResult = decoder.decode(ByteBuffer.allocate(0), out, true);
				decoder.flush(out);
				if (lastDecodeResult.isError())
					lastDecodeResult.throwException();
				out.flip();
			}
		}
		
		private static int indexOf(char[] array, int beginIndex)
		{
			int i = beginIndex;
			while (i &lt; array.length)
				if (array[i++] == '\n')
					return i - beginIndex;
			
			return -1;
		}

		public void producer()
		{
			char elements[] = out.toString().toCharArray();
			String residual = &quot;&quot;;
			int beginIndex = 0;
			
			try
			{
				while (beginIndex &lt; elements.length)
				{
					int nl = indexOf(elements, beginIndex);
					
					if (nl &gt;= 0)
					{
						String element = new String(elements, beginIndex, nl - 1);
						beginIndex += nl;
						if (!residual.isEmpty())
						{
							element = residual + element;
							residual = &quot;&quot;;
						}
							
						final int length = element.length();
						if (element.charAt(length - 1) == '\r')
							element = element.substring(0, length - 1);
						//LOGGER.trace(&quot;Read line from csv: {}&quot;, element);
						queue.put(element);
					}
					else
					{
						fill();
						
						if (out.hasRemaining())
						{
							if (beginIndex &lt; elements.length)
								residual += new String(elements, beginIndex, elements.length - beginIndex);
							elements = out.toString().toCharArray();
							beginIndex = 0;
						}
						else
							queue.put(residual + new String(elements));
					}
				}
			}
			catch (IOException | InterruptedException e)
			{
				LOGGER.error(&quot;Error while reading CSV: &quot;, e);
				throw new RuntimeException(e);
			}
			
			LOGGER.debug(&quot;Finished reading CSV&quot;);
		}

		@Override
		public boolean tryAdvance(Consumer&lt;? super String&gt; action)
		{
			if (counter.getAndIncrement() &gt;= lines)
				return false;
			
			try
			{
				action.accept(queue.take());
				return true;
			}
			catch (InterruptedException e)
			{
				return false;
			}
		}
		
		@Override
		public Spliterator&lt;String&gt; trySplit()
		{
			splits++;
			return this;
		}
		
		@Override
		public int characteristics()
		{
			return Spliterator.IMMUTABLE + Spliterator.CONCURRENT + Spliterator.SIZED + Spliterator.NONNULL;
		}

		@Override
		public long estimateSize()
		{
			return (lines - counter.get()) / splits;
		}
	}*/
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>